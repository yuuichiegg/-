<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>統合版 地震情報ビューア (総合防災AI版) - v6.0</title>
    
    <!-- Leaflet.js CSS and Script -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles */
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100vw; }
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        .plate-tooltip { background-color: rgba(0, 0, 0, 0.7) !important; border: none !important; box-shadow: none !important; color: white !important; font-weight: bold; font-size: 14px; padding: 4px 8px !important; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 1rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Modal styles with animation */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-container {
            background-color: white; padding: 0; border-radius: 0.5rem;
            width: 90%; max-width: 500px; max-height: 85vh;
            display: flex; flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .modal-overlay.visible .modal-container { transform: scale(1); }
        .modal-header { flex-shrink: 0; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; cursor: move; }
        .modal-body { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        .modal-footer { flex-shrink: 0; text-align: right; padding: 1rem 1.5rem; border-top: 1px solid #e5e7eb; }
        .modal-container h2 { font-size: 1.5rem; font-weight: bold; }
        .modal-container h3 { font-size: 1.2rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .modal-container p, .modal-container ul { font-size: 0.9rem; line-height: 1.8; margin-bottom: 1rem; }
        .modal-container li { margin-left: 1.5rem; list-style-type: disc; }
        
        /* Floating Toolbox */
        #toolbox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            border-radius: 999px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 8px;
        }
        .tool-button {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .tool-button:hover { background-color: #e5e7eb; transform: translateY(-2px); }
        .tool-button svg { width: 24px; height: 24px; }
        
        .map-pin-mode { cursor: crosshair !important; }
        #drone-dashboard {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 500;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            width: 280px;
            border: 1px solid #ccc;
        }
        #drone-dashboard h4 { font-weight: bold; }
        #mission-log {
            font-family: monospace;
            font-size: 11px;
            background-color: #2d3748;
            color: #a0aec0;
            padding: 8px;
            border-radius: 4px;
            height: 100px;
            overflow-y: auto;
            margin-top: 8px;
        }
        .drone-icon { transition: all 1s linear; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="map-container" class="w-screen h-screen relative">
        <div id="map"></div>
        <div id="drone-dashboard" class="hidden"></div>
    </div>
    
    <div id="toolbox">
        <button id="mode-toggle-button" class="tool-button" title="モード切替"></button>
        <button id="filter-button" class="tool-button" title="フィルター">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.572a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" /></svg>
        </button>
        <button id="ai-tools-button" class="tool-button" title="AI防災ツール">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM18 15.75l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 18l-1.035.259a3.375 3.375 0 00-2.456 2.456L18 21.75l-.259-1.035a3.375 3.375 0 00-2.456-2.456L14.25 18l1.035-.259a3.375 3.375 0 002.456-2.456L18 15.75z" /></svg>
        </button>
        <button id="info-share-button" class="tool-button" title="情報共有">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        </button>
        <button id="drone-request-button" class="tool-button" title="ドローン支援要請">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
        </button>
    </div>

    <!-- Modals -->
    <div id="modal-container"></div>

    <!-- Main application logic -->
    <script type="module">
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants and Global Variables ---
        const USGS_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson';
        const USGS_DISASTER_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson';
        const P2P_API_BASE_URL = 'https://api.p2pquake.net/v2/history?codes=551&limit=';
        const TECTONIC_PLATES_URL = 'https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_plates.json';
        
        let currentMode = 'japan';
        let allEarthquakeData = [];
        let filteredEarthquakeData = [];
        let quakeMarkers = {};
        let isApiCallInProgress = false;
        let userCoords = null;
        let droneAnimationId = null;

        // --- DOM Elements ---
        const modalContainer = document.getElementById('modal-container');
        const droneDashboard = document.getElementById('drone-dashboard');

        // --- Leaflet Map Initialization ---
        const map = L.map('map');
        const quakeLayer = L.layerGroup().addTo(map);
        const platesLayer = L.layerGroup();
        const tsunamiLayer = L.layerGroup().addTo(map);
        const notesLayer = L.layerGroup().addTo(map);
        const droneLayer = L.layerGroup().addTo(map);
        const gsiTile = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
            attribution: "<a href='https://maps.gsi.go.jp/development/ichiran.html' target='_blank'>地理院タイル</a>"
        }).addTo(map);
        const baseMaps = { "地理院タイル": gsiTile };
        const overlayMaps = { "地震情報": quakeLayer, "プレート": platesLayer, "津波浸水予測": tsunamiLayer, "共有情報": notesLayer, "ドローン": droneLayer };
        L.control.layers(baseMaps, overlayMaps).addTo(map);
        
        // --- Gemini API Call ---
        async function callGeminiApi(prompt) {
            setApiButtonsState(true);
            const apiKey = ""; // Handled by Canvas
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`APIリクエストに失敗しました: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) return result.candidates[0].content.parts[0].text;
                else throw new Error('無効なAPIレスポンスです。');
            } catch (error) {
                console.error("Gemini API Error:", error);
                return `エラーが発生しました: ${error.message}`;
            } finally { setApiButtonsState(false); }
        }

        // --- Feature Functions ---
        async function generateAnalysis() {
            showModal('✨ AIによる分析と見通し', '<div class="spinner"></div>');
            if (filteredEarthquakeData.length === 0) { 
                updateModalContent('<p>分析対象の地震データがありません。</p>'); return;
            }
            const largestQuake = filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]);
            const dataSummary = `最大地震: M${largestQuake.earthquake.hypocenter.magnitude.toFixed(1)} at ${largestQuake.displayPlace}. 地震件数: ${filteredEarthquakeData.length}.`;
            const prompt = `あなたは冷静で信頼できる地震学者です。以下の地震データ概要を基に、一般市民向けの簡潔な分析レポートを作成してください。レポートには以下の要素を含めてください。1. **活動の概要**: 最大地震や活発な地域について言及。2. **地質学的背景**: プレートの動きなど、地震の発生メカニズムを簡単に解説。3. **今後の見通し**: 特定の予測はせず、一般的な注意喚起（例：余震の可能性）に留める。4. **防災への呼びかけ**: ポジティブかつ具体的に、日頃の備えの重要性を訴える。全体をMarkdown形式で、親しみやすく、かつ権威を損なわないトーンで記述してください。データ概要: ${dataSummary}`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateSafetyReport(location, household) {
            if (!location) { 
                showModal('エラー', '<p>場所を指定してください。</p>');
                return;
            }
            showModal('✨ MY防災レポート', '<div class="spinner"></div>');
            const dataSummary = `現在の地震活動の最大規模はM${filteredEarthquakeData.reduce((max, q) => Math.max(max, q.earthquake.hypocenter.magnitude), 0).toFixed(1)}です。`;
            const prompt = `あなたは地域の防災アドバイザーです。ユーザーは「${location}」に住んでおり、世帯構成は「${household}」です。現在の地震活動（${dataSummary}）を踏まえ、その地域と世帯構成に特化したパーソナルな防災レポートを作成してください。レポートには以下の要素を含めてください。1. **地域特性の考慮**: ${location}の地理的特徴（例：沿岸部、都市部、山間部など）を考慮した具体的なリスクについて言及。2. **世帯構成に合わせた備え**: 「${household}」に特に重要な、具体的なアクションを提案。3. **備蓄品リスト**: 世帯構成に合わせた非常用持ち出し袋の中身をリスト形式で提案。4. **物資確保のアドバイス**: 災害時に水、食料、バッテリーなどの物資を確保するための具体的なアイデアを提案してください。5. **心のケア**: 不安を煽らず、備えることの重要性をポジティブに伝える。全体をMarkdown形式で、親しみやすく、具体的で役立つ内容にしてください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePreparednessTips() {
            showModal('💡 事前の備え (AI防災アドバイザー)', '<div class="spinner"></div>');
            const prompt = `あなたは経験豊富な防災コンサルタントです。地震が発生する前に家庭でできる予防策や、防災計画のアイデアをいくつか提案してください。家具の固定方法、備蓄品の選び方、家族との連絡方法の確認など、読者がすぐに行動に移せるような具体的で実践的なアドバイスをMarkdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePowerOutageReport() {
            const locationInput = document.getElementById('location-input');
            if (!locationInput || !locationInput.value) {
                showModal('エラー', '<p>停電リスク分析には、まず「MY防災レポート」セクションで場所を指定してください。</p>');
                return;
            }
            showModal('💡 停電リスク分析 (AI)', '<div class="spinner"></div>');
            const largestQuake = filteredEarthquakeData.length > 0 ? filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]) : null;
            const prompt = `あなたは電力インフラに詳しい防災専門家です。ユーザーは「${locationInput.value}」にいます。現在、最大M${largestQuake ? largestQuake.earthquake.hypocenter.magnitude.toFixed(1) : '不明'}の地震が観測されています。この状況を踏まえ、以下の点についてアドバイスをください。
            1. **停電の可能性**: この規模の地震で、${locationInput.value}で停電が発生する一般的な可能性は？
            2. **復旧の見通し**: もし停電した場合、復旧にはどのくらいの時間がかかる可能性があるか？
            3. **今すぐできる対策**: 停電に備えて、今すぐできることは何か？(例: スマートフォンの充電、懐中電灯の準備など)
            専門的かつ分かりやすい言葉で、Markdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generateDroneFutureReport() {
            showModal('🤖 AIと語るドローンの未来', '<div class="spinner"></div>');
            const prompt = `あなたはテクノロジーと社会の未来に詳しいアナリストです。「災害対策におけるドローンの重要性と今後の展望」というテーマで、一般向けの解説記事を執筆してください。以下の要素を必ず含めてください。
            1. **現在の活用事例**: 物資輸送、情報収集、被災者捜索など。
            2. **未来の可能性**: 1対n運航（群制御）、AIによる自律判断、救助活動への直接参加など、さらに進んだ活用方法。
            3. **解決すべき課題**: 法整備、機体性能の向上（バッテリー、積載量）、プライバシー保護、社会的な受容性など。
            読者が未来に希望を持てるような、前向きなトーンでMarkdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateTransitAdvice() {
            showModal('🚗 交通機関向けAIアドバイス', '<div class="spinner"></div>');
            const prompt = `あなたは災害危機管理の専門家です。地震発生時に、様々な交通機関を利用している人々（運転手や乗客）に向けて、それぞれの状況に応じた具体的で安全な行動指針をアドバイスしてください。以下の項目を必ず含めてください。
            - **自動車を運転中の場合**
            - **バスやタクシーに乗車中の場合**
            - **鉄道（電車・新幹線）に乗車中の場合**
            - **バイクや自転車に乗っている場合**
            各項目で、「揺れている最中の行動」と「揺れが収まった後の行動」を明確に分けて説明してください。Markdown形式で、簡潔かつ分かりやすく記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function handleDroneRequest() {
            const locationInput = document.getElementById('location-input');
            if (!locationInput || !locationInput.value) {
                showModal('エラー', '<p>ドローン支援要請には、まず「MY防災レポート」セクションで場所を指定してください。</p>');
                return;
            }

            const modalId = `modal-drone-${Date.now()}`;
            const modalContent = `
                <p class="text-sm">要請場所: <strong>${locationInput.value}</strong></p>
                <p>必要な物資を選択してください（複数選択可）：</p>
                <div class="space-y-2 my-4">
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="医薬品" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">医薬品 (応急手当セットなど)</span></label>
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="食料・水" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">食料・水 (最低1日分)</span></label>
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="バッテリー" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">バッテリー (モバイル用)</span></label>
                </div>
                <div class="text-right">
                    <button id="submit-drone-request" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-md hover:bg-sky-700">AIによるシミュレーションを開始</button>
                </div>
                <div id="drone-response-container" class="mt-4"></div>
            `;
            const modalEl = showModal('🚁 ドローン支援要請 (シミュレーション)', modalContent, modalId);
            
            modalEl.querySelector('#submit-drone-request').addEventListener('click', async () => {
                const droneResponseContainer = modalEl.querySelector('.modal-body');
                const selectedSupplies = Array.from(modalEl.querySelectorAll('input[name="drone-supplies"]:checked')).map(cb => cb.value);
                if (selectedSupplies.length === 0) {
                    droneResponseContainer.innerHTML = '<p class="text-red-500">少なくとも1つの物資を選択してください。</p>';
                    return;
                }
                droneResponseContainer.innerHTML = '<div class="spinner"></div>';
                const prompt = `あなたは災害対応ドローンの運用AIです。ユーザーから以下の内容で支援要請がありました。応答をJSON形式で生成してください。
                - **要請場所**: ${locationInput.value}
                - **要請場所の座標**: ${userCoords ? `緯度${userCoords.lat}, 経度${userCoords.lng}`: '不明'}
                - **要請物資**: ${selectedSupplies.join(', ')}
                - **現在の状況**: 大規模な地震が発生し、交通網に影響が出ている可能性がある。

                応答JSONの仕様:
                {
                  "departurePointName": "（${locationInput.value} 内の具体的な出発拠点名。市役所、大きな公園など）",
                  "departurePointLat": （出発地点の緯度）,
                  "departurePointLng": （出発地点の経度）,
                  "estimatedFlightMinutes": （現実的な飛行時間（分））,
                  "missionLog": [
                      {"time": 0, "event": "要請を受理しました。ドローンを発進準備中です。"},
                      {"time": 1, "event": "ドローンが拠点（${locationInput.value}防災センター）から離陸しました。"},
                      {"time": 5, "event": "高度100m、速度50km/hで安定飛行中。"},
                      {"time": 8, "event": "他の緊急車両との重複を避けるため、一時的にルートを調整します。"},
                      {"time": 12, "event": "目的地まであとわずかです。安全な場所で待機してください。"}
                  ],
                  "narrative": "（ユーザーへの応答メッセージ。要請受理、発進、到着予定、飛行経路、受け取り時の注意、免責事項を含むMarkdown形式のテキスト）"
                }`;
                const resultText = await callGeminiApi(prompt);
                try {
                    const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) throw new Error("AIの応答にJSONデータが含まれていません。");
                    const jsonString = jsonMatch[0];
                    const resultJson = JSON.parse(jsonString);
                    
                    const responseHtml = formatTextToHtml(resultJson.narrative);
                    droneResponseContainer.innerHTML = `<div id="drone-map"></div>${responseHtml}`;
                    
                    if(userCoords) {
                        const startPoint = [resultJson.departurePointLat, resultJson.departurePointLng];
                        const endPoint = [userCoords.lat, userCoords.lng];
                        const droneMap = L.map('drone-map');
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(droneMap);
                        initializeDroneMap(droneMap, startPoint, endPoint, resultJson.estimatedFlightMinutes, resultJson.missionLog);
                    }
                } catch(e) {
                    console.error("Failed to parse drone response JSON", e);
                    droneResponseContainer.innerHTML = `<p class="text-red-500">AIからの応答を解析できませんでした。通常のテキストで表示します。</p>${formatTextToHtml(resultText)}`;
                }
            });
        }

        async function getHistoricalContext(quake) {
            showModal('✨ AIによる地域の地震履歴分析', '<div class="spinner"></div>');
            const prompt = `あなたは地震の歴史に詳しい専門家です。マグニチュード${quake.earthquake.hypocenter.magnitude.toFixed(1)}の地震が「${quake.displayPlace}」で発生しました。この地域における過去の特筆すべき地震活動や、プレートテクトニクスの観点からの地質学的な背景について、一般の人にも分かりやすく簡潔に解説してください。この地域は地震が多いことで知られていますか？もしあなたの知識ベースに著名な過去の地震があれば、それに言及してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        function handleTsunamiSimulation(quake) {
            if (!quake.earthquake.tsunami) {
                showModal('津波情報', '<p>この地震による津波の心配はありません。</p>');
                return;
            }
            if (!userCoords) {
                showModal('エラー', '<p>シミュレーションには、まず「MY防災レポート」セクションであなたの場所を指定してください。</p>');
                return;
            }

            tsunamiLayer.clearLayers();
            
            // Simulate inundation zone
            const center = [quake.earthquake.hypocenter.latitude, quake.earthquake.hypocenter.longitude];
            const radius = 10000 + quake.earthquake.hypocenter.magnitude * 2000; // Simplified radius
            const circle = L.circle(center, {
                color: 'blue',
                fillColor: '#3388ff',
                fillOpacity: 0.3,
                radius: radius
            }).addTo(tsunamiLayer);

            // Simulate evacuation route
            const userLatLng = L.latLng(userCoords.lat, userCoords.lng);
            // Simple logic: find a point away from the quake epicenter
            const bearing = map.project(center).subtract(map.project(userLatLng)).angle();
            const evacuationPoint = L.latLng(
                userLatLng.lat + Math.sin(bearing) * 0.05, // Approx 5km away
                userLatLng.lng + Math.cos(bearing) * 0.05
            );
            
            const route = L.polyline([userLatLng, evacuationPoint], {color: 'green', dashArray: '5, 5'}).addTo(tsunamiLayer);
            const shelterIcon = L.divIcon({className: 'text-4xl', html: '🏫'});
            L.marker(evacuationPoint, {icon: shelterIcon}).addTo(tsunamiLayer).bindTooltip("高台避難場所 (シミュレーション)");

            map.fitBounds(L.featureGroup([circle, route]).getBounds().pad(0.2));
            
            showModal('津波・避難シミュレーション', '<div class="analysis-disclaimer"><strong>【重要】</strong>これはシミュレーションです。実際の浸水域や避難経路とは異なります。実際の避難は、必ず自治体の指示に従ってください。</div><p>地図上に青で想定浸水域、緑の破線で高台への避難ルート（シミュレーション）を表示しました。</p>');
        }

        function switchMode(newMode) {
            if (currentMode === newMode && allEarthquakeData.length > 0) return;
            currentMode = newMode;
            map.setView(newMode === 'world' ? [20, 0] : [36, 138], newMode === 'world' ? 2 : 5);
            setTimeout(() => map.invalidateSize(), 0);
            allEarthquakeData = [];
            filteredEarthquakeData = [];
            fetchData();
        }

        function fetchData() {
            if (currentMode === 'world') {
                fetchWorldData();
            } else {
                fetchJapanData();
            }
        }

        function applyFilters() {
            const magFilter = document.getElementById('mag-filter');
            const minMag = magFilter ? parseFloat(magFilter.value) : 0;
            
            filteredEarthquakeData = allEarthquakeData.filter(quake => quake.earthquake.hypocenter.magnitude >= minMag);
            
            if (currentMode === 'world') {
                const regionFilter = document.getElementById('region-filter');
                const selectedRegion = regionFilter ? regionFilter.value : 'all';
                if (selectedRegion !== 'all') {
                    filteredEarthquakeData = filteredEarthquakeData.filter(quake => quake.region === selectedRegion);
                }
            }
            renderEarthquakes(filteredEarthquakeData);
        }

        function renderEarthquakes(data) {
            const listElement = document.getElementById('earthquake-list');
            const quakeCount = document.getElementById('quake-count');
            
            quakeLayer.clearLayers();
            quakeMarkers = {};

            if (listElement) listElement.innerHTML = '';
            if (quakeCount) quakeCount.textContent = data.length;

            if (!data || data.length === 0) {
                if(listElement) listElement.innerHTML = '<li class="p-4 text-center text-gray-500">表示できる地震情報がありません。</li>'; 
                return;
            }
            
            data.sort((a, b) => b.time - a.time);
            
            data.forEach(quake => {
                const { hypocenter, tsunami, shindo } = quake.earthquake;
                const { latitude, longitude, magnitude, depth } = hypocenter;
                const { displayPlace, displayTime } = quake;
                const quakeId = quake.id;
                const radius = Math.pow(1.8, magnitude) * (currentMode === 'world' ? 3000 : 500);
                const fillColor = currentMode === 'world' ? getMagnitudeColor(magnitude) : getJmaShindoColor(shindo.value);
                const defaultStyle = { color: "#111", weight: 1, fillColor: fillColor, fillOpacity: 0.7, radius: radius };
                const highlightStyle = { color: "#000000", weight: 4 };
                const circle = L.circle([latitude, longitude], defaultStyle);
                const shindoLabel = shindo.type === 'JMA' ? '気象庁震度' : 'MMI震度';
                const shindoValue = shindo.value || '情報なし';
                
                const popupContent = document.createElement('div');
                popupContent.className = 'font-sans space-y-2';
                popupContent.innerHTML = `<strong class="text-base">発生時刻:</strong> ${displayTime}<br><strong class="text-base">震源地:</strong> ${displayPlace}<br><strong class="text-base">マグニチュード:</strong> ${magnitude.toFixed(1)}<br><strong class="text-base">深さ:</strong> ${depth.toFixed(1)} km<br><strong class="text-base">${shindoLabel}:</strong> ${shindoValue}<br><strong class="text-base">津波の可能性:</strong> ${tsunami ? 'あり' : 'なし'}`;
                
                const historyButton = document.createElement('button');
                historyButton.className = 'w-full text-sm bg-purple-600 text-white font-bold py-1 px-2 rounded-md hover:bg-purple-700 transition-colors';
                historyButton.innerHTML = '✨ この地域の過去の活動をAI分析';
                historyButton.onclick = () => getHistoricalContext(quake);
                
                const tsunamiButton = document.createElement('button');
                tsunamiButton.className = 'w-full text-sm bg-cyan-600 text-white font-bold py-1 px-2 rounded-md hover:bg-cyan-700 transition-colors';
                tsunamiButton.innerHTML = '🌊 津波・避難シミュレーション';
                tsunamiButton.onclick = () => handleTsunamiSimulation(quake);

                popupContent.appendChild(historyButton);
                popupContent.appendChild(tsunamiButton);
                circle.bindPopup(popupContent);

                quakeLayer.addLayer(circle);
                
                if (listElement) {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-3 border rounded-lg shadow-sm list-item-hover transition-colors duration-200';
                    listItem.innerHTML = `<div class="font-semibold text-gray-800">${displayPlace} ${tsunami ? '🌊' : ''}</div><div class="text-sm text-gray-600">${displayTime}</div><div class="flex flex-wrap justify-between items-center mt-2 text-sm gap-x-4 gap-y-1"><span class="font-bold px-2 py-1 rounded-md" style="background-color:${fillColor}; color: ${isDarkColor(fillColor) ? 'white' : 'black'}">マグニチュード ${magnitude.toFixed(1)}</span><span>深さ: ${depth.toFixed(1)} km</span><span>${shindoLabel}: ${shindoValue}</span></div>`;
                    listItem.addEventListener('mouseover', () => { circle.setStyle(highlightStyle).bringToFront(); });
                    listItem.addEventListener('mouseout', () => { circle.setStyle(defaultStyle); });
                    listItem.addEventListener('click', () => { map.flyTo([latitude, longitude], 6); circle.openPopup(); });
                    listElement.appendChild(listItem);
                }
                quakeMarkers[quakeId] = { circle };
            });
        }
        
        async function fetchTectonicPlates() {
            const plateNameMap = { "African": "アフリカプレート", "Antarctic": "南極プレート", "Arabian": "アラビアプレート", "Australian": "オーストラリアプレート", "Caribbean": "カリブプレート", "Cocos": "ココスプレート", "Eurasian": "ユーラシアプレート", "Indian": "インドプレート", "Juan de Fuca": "ファンデフカプレート", "Nazca": "ナスカプレート", "North American": "北米プレート", "Okhotsk": "オホーツクプレート", "Pacific": "太平洋プレート", "Philippine Sea": "フィリピン海プレート", "Scotia": "スコシアプレート", "South American": "南米プレート" };
            try {
                const response = await fetch(TECTONIC_PLATES_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const platesData = await response.json();
                L.geoJSON(platesData, { style: { color: "#ff7800", weight: 2, opacity: 0.65, fillColor: "#ff7800", fillOpacity: 0.1 }, onEachFeature: (feature, layer) => { if (feature.properties && feature.properties.PlateName) { const displayName = plateNameMap[feature.properties.PlateName] || feature.properties.PlateName; layer.bindTooltip(displayName, { permanent: false, direction: 'center', className: 'plate-tooltip' }); } } }).addTo(platesLayer);
            } catch (error) { console.error('Failed to fetch tectonic plates data:', error); }
        }

        async function fetchWorldData(isDisaster = false) {
            const url = isDisaster ? USGS_DISASTER_API_URL : USGS_API_URL;
            const countryNameMap = { "CA": "カリフォルニア", "California": "カリフォルニア", "Alaska": "アラスカ", "Hawaii": "ハワイ", "Indonesia": "インドネシア", "Japan": "日本", "Philippines": "フィリピン", "Fiji": "フィジー", "Chile": "チリ", "Mexico": "メキシコ", "New Zealand": "ニュージーランド", "Russia": "ロシア", "Papua New Guinea": "パプアニューギニア", "Tonga": "トンガ", "Vanuatu": "バヌアツ", "Solomon Islands": "ソロモン諸島", "Taiwan": "台湾", "China": "中国", "Turkey": "トルコ", "Greece": "ギリシャ", "Italy": "イタリア", "Iran": "イラン", "Peru": "ペルー", "Argentina": "アルゼンチン", "Colombia": "コロンビア", "Ecuador": "エクアドル", "Guatemala": "グアテマラ", "Costa Rica": "コスタリカ", "Nicaragua": "ニカラグア", "El Salvador": "エルサルバドル", "Honduras": "ホンジュラス", "Panama": "パナマ", "Puerto Rico": "プエルトリコ", "Dominican Republic": "ドミニカ共和国", "Iceland": "アイスランド", "Portugal": "ポルトガル", "Spain": "スペイン", "India": "インド", "Pakistan": "パキスタン", "Afghanistan": "アフガニスタン", "Kyrgyzstan": "キルギス", "Tajikistan": "タジキスタン", "Uzbekistan": "ウズベキスタン" };
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                const regions = new Set();
                allEarthquakeData = data.features.map(feature => {
                    const place = feature.properties.place; const latitude = feature.geometry.coordinates[1]; const longitude = feature.geometry.coordinates[0];
                    let region = place, japanesePlace = place, isJapan = false;
                    if (place && place.includes(',')) { const parts = place.split(','); region = parts[parts.length - 1].trim(); if (region === "Japan") isJapan = true; const translatedRegion = countryNameMap[region] || region; japanesePlace = `${translatedRegion} - ${parts.slice(0, -1).join(',')}`; } else if (place && place.toLowerCase().includes("japan")) { isJapan = true; region = "Japan"; japanesePlace = place; }
                    regions.add(region);
                    const isNearJapan = latitude >= 20 && latitude <= 46 && longitude >= 122 && longitude <= 154;
                    const displayTime = isNearJapan ? new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (日本時間)' : new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'UTC' }) + ' (協定世界時)';
                    return { id: feature.id, time: feature.properties.time, region: region, displayPlace: japanesePlace, isJapan: isJapan, displayTime: displayTime, earthquake: { hypocenter: { latitude: latitude, longitude: longitude, depth: feature.geometry.coordinates[2], magnitude: feature.properties.mag }, tsunami: feature.properties.tsunami, shindo: { type: isJapan ? 'JMA' : 'MMI', value: isJapan ? convertMmiToJmaShindo(feature.properties.mmi) : convertMmiToRoman(feature.properties.mmi) } } };
                });
                populateRegionFilter(regions); applyFilters();
            } catch (error) { console.error('Failed to fetch world data:', error); }
        }
        
        async function fetchJapanData(limit = 100) {
            try {
                const response = await fetch(P2P_API_BASE_URL + limit);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                allEarthquakeData = data.map(q => {
                    const { earthquake, id, time } = q;
                    return { id: id, time: new Date(time).getTime(), region: 'Japan', displayPlace: earthquake.hypocenter.name, isJapan: true, displayTime: new Date(time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (日本時間)', earthquake: { hypocenter: { latitude: parseFloat(earthquake.hypocenter.latitude), longitude: parseFloat(earthquake.hypocenter.longitude), depth: parseFloat(earthquake.hypocenter.depth), magnitude: parseFloat(earthquake.hypocenter.magnitude) }, tsunami: earthquake.tsunami?.text.includes('津波の心配はありません') === false, shindo: { type: 'JMA', value: convertScale(earthquake.maxScale) } } };
                });
                applyFilters();
            } catch(error) { console.error('Failed to fetch Japan data:', error); }
        }

        function populateRegionFilter(regions) {
            const regionFilter = document.getElementById('region-filter-modal');
            if(!regionFilter) return;
            regionFilter.innerHTML = '<option value="all">すべて表示</option>';
            const sortedRegions = Array.from(regions).sort();
            sortedRegions.forEach(region => { const option = document.createElement('option'); option.value = region; option.textContent = region; regionFilter.appendChild(option); });
        }
        
        // --- Modal and Policy/Terms Logic ---
        function showModal(title, content, modalId = `modal-${Date.now()}`) {
            const existingModal = document.getElementById(modalId);
            if(existingModal) existingModal.remove();

            const modalEl = document.createElement('div');
            modalEl.id = modalId;
            modalEl.className = 'modal-overlay';
            modalEl.innerHTML = `
                <div class="modal-container">
                    <div class="modal-header">
                        <h2 class="text-2xl font-bold mb-4">${title}</h2>
                    </div>
                    <div class="modal-body">${content}</div>
                    <div class="modal-footer">
                        <button class="modal-close bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600">閉じる</button>
                    </div>
                </div>`;
            modalContainer.appendChild(modalEl);
            
            // Trigger fade-in animation
            setTimeout(() => modalEl.classList.add('visible'), 10);

            const close = () => {
                modalEl.classList.remove('visible');
                setTimeout(() => modalEl.remove(), 300);
            };
            
            modalEl.querySelector('.modal-close').addEventListener('click', close);
            modalEl.addEventListener('click', (e) => { if (e.target === modalEl) close(); });
            return modalEl;
        }

        function updateModalContent(content, modalEl) {
            const target = modalEl ? modalEl.querySelector('.modal-body') : modalContainer.querySelector('.modal-overlay:last-child .modal-body');
            if(target) target.innerHTML = content;
        }
        
        // --- Utility Functions ---
        function formatTextToHtml(text) {
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/### (.*$)/gm, '<h4>$1</h4>')
                .replace(/## (.*$)/gm, '<h3>$1</h3>')
                .replace(/# (.*$)/gm, '<h2>$1</h2>')
                .replace(/^\* (.*$)/gm, '<li>$1</li>');
            html = html.replace(/<li>/g, '<ul><li>').replace(/<\/li>/g, '</li></ul>');
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            return html.replace(/\n/g, '<br>').replace(/<br><br>/g, '<br>');
        }
        function setApiButtonsState(inProgress) {
            isApiCallInProgress = inProgress;
            document.querySelectorAll('#toolbox button').forEach(button => button.disabled = inProgress);
        }
        function getMagnitudeColor(mag) { if (mag >= 7) return '#b30000'; if (mag >= 6) return '#d73027'; if (mag >= 5) return '#fc8d59'; if (mag >= 4) return '#fee08b'; return '#91cf60'; }
        function getJmaShindoColor(shindo) { const map = { '7':'#580b27', '6強':'#b30000', '6弱':'#d73027', '5強':'#fc8d59', '5弱':'#fee08b', '4':'#ffffbf', '3':'#d9ef8b', '2':'#91cf60', '1':'#1a9850', '0':'#cccccc' }; return map[shindo] || '#cccccc'; }
        function convertMmiToRoman(mmi) { if (mmi == null || mmi < 1) return '情報なし'; const map = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}; const roundedMmi = Math.round(mmi); if (roundedMmi >= 10) return 'X+'; return map[roundedMmi] || '情報なし'; }
        function convertMmiToJmaShindo(mmi) { if (mmi == null || mmi < 0) return '情報なし'; if (mmi < 0.5) return '0'; if (mmi < 1.5) return '1'; if (mmi < 2.5) return '2'; if (mmi < 3.5) return '3'; if (mmi < 4.5) return '4'; if (mmi < 5.0) return '5弱'; if (mmi < 5.5) return '5強'; if (mmi < 6.0) return '6弱'; if (mmi < 6.5) return '6強'; return '7'; }
        function convertScale(scale) { const scaleMap = { 10:'1', 20:'2', 30:'3', 40:'4', 45:'5弱', 50:'5強', 55:'6弱', 60:'6強', 70:'7' }; return scaleMap[scale] ?? '不明'; }
        function isDarkColor(hexcolor) { if (!hexcolor.startsWith('#')) return false; const r = parseInt(hexcolor.substr(1, 2), 16), g = parseInt(hexcolor.substr(3, 2), 16), b = parseInt(hexcolor.substr(5, 2), 16); return ((r * 299) + (g * 587) + (b * 114)) / 1000 < 128; }

        // --- Location Picker Logic ---
        function enterPinMode() {
            L.DomUtil.addClass(map.getContainer(), 'map-pin-mode');
            map.once('click', onMapClick);
        }
        async function onMapClick(e) {
            const { lat, lng } = e.latlng;
            userCoords = { lat, lng };
            L.DomUtil.removeClass(map.getContainer(), 'map-pin-mode');
            const locationInput = document.getElementById('location-input');
            locationInput.value = '座標から住所を検索中...';
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=ja`);
                if(!response.ok) throw new Error("Network response was not ok.");
                const data = await response.json();
                if (data && data.address) {
                    const address = data.address;
                    const displayAddress = `${address.country || ''} ${address.state || ''} ${address.city || address.town || address.village || ''}`.trim();
                    locationInput.value = displayAddress || '住所が見つかりません';
                } else {
                    locationInput.value = '住所が見つかりませんでした';
                }
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                locationInput.value = '住所の取得に失敗しました';
            }
        }
        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => onMapClick({ latlng: { lat: position.coords.latitude, lng: position.coords.longitude } }),
                    (error) => { alert(`GPS情報の取得に失敗しました: ${error.message}`); }
                );
            } else {
                alert("お使いのブラウザはGPS機能に対応していません。");
            }
        }
        
        function initializeDroneMap(droneMapInstance, start, end, durationMinutes, missionLog) {
            const startCoords = L.latLng(start[0], start[1]);
            const endCoords = L.latLng(end[0], end[1]);

            const destinationIcon = L.divIcon({className: 'text-4xl', html: '🏠'});
            const droneBaseIcon = L.divIcon({className: 'text-4xl', html: '📡'});
            const droneIcon = L.divIcon({className: 'text-4xl drone-icon', html: '🚁'});

            L.marker(endCoords, {icon: destinationIcon}).addTo(droneMapInstance).bindTooltip("目的地");
            L.marker(startCoords, {icon: droneBaseIcon}).addTo(droneMapInstance).bindTooltip("ドローン基地");
            
            const route = L.polyline([startCoords, endCoords], {color: 'blue', dashArray: '5, 10'}).addTo(droneMapInstance);
            droneMapInstance.fitBounds(route.getBounds().pad(0.2));

            const movingDrone = L.marker(startCoords, {icon: droneIcon}).addTo(droneMapInstance);
            animateDrone(movingDrone, route, durationMinutes * 60 * 1000, missionLog);
        }
        
        function animateDrone(marker, route, duration, missionLog) {
            if (droneAnimationId) cancelAnimationFrame(droneAnimationId);
            let start = null;
            const latlngs = route.getLatLngs();
            const missionLogEl = document.getElementById('drone-response-container')?.querySelector('#mission-log');
            const speedEl = document.getElementById('drone-response-container')?.querySelector('#drone-speed');
            const altitudeEl = document.getElementById('drone-response-container')?.querySelector('#drone-altitude');
            const batteryEl = document.getElementById('drone-response-container')?.querySelector('#drone-battery');
            const etaEl = document.getElementById('drone-response-container')?.querySelector('#drone-eta');

            let currentLogIndex = 0;

            function animationStep(timestamp) {
                if (!start) start = timestamp;
                const progress = timestamp - start;
                const ratio = Math.min(progress / duration, 1);

                if (missionLogEl && (currentLogIndex < missionLog.length) && (missionLog[currentLogIndex].time * 60 * 1000) <= progress) {
                    const logEntry = document.createElement('p');
                    logEntry.textContent = `[${new Date(Date.now() + progress).toLocaleTimeString()}] ${missionLog[currentLogIndex].event}`;
                    missionLogEl.appendChild(logEntry);
                    missionLogEl.scrollTop = missionLogEl.scrollHeight;
                    currentLogIndex++;
                }

                if(speedEl) speedEl.textContent = `${(50 + Math.random() * 10).toFixed(1)} km/h`;
                if(altitudeEl) altitudeEl.textContent = `${(100 + Math.random() * 20).toFixed(1)} m`;
                if(batteryEl) batteryEl.textContent = `${(100 - ratio * 70).toFixed(1)} %`;
                const remainingMinutes = (duration - progress) / 1000 / 60;
                if(etaEl) etaEl.textContent = `${Math.max(0, remainingMinutes).toFixed(1)} 分`;

                if (ratio < 1) {
                    const newLatLng = L.latLng(
                        latlngs[0].lat + ratio * (latlngs[1].lat - latlngs[0].lat),
                        latlngs[0].lng + ratio * (latlngs[1].lng - latlngs[0].lng)
                    );
                    marker.setLatLng(newLatLng);
                    droneAnimationId = requestAnimationFrame(animationStep);
                } else {
                    marker.setLatLng(latlngs[1]);
                    marker.setIcon(L.divIcon({className: 'text-4xl', html: '✅'}));
                    if(etaEl) etaEl.textContent = '到着済み';
                }
            }
            droneAnimationId = requestAnimationFrame(animationStep);
        }

        // --- Event Listeners ---
        document.body.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if(!target) return;
            
            const targetId = target.id;
            switch(targetId) {
                case 'prepare-button': generatePreparednessTips(); break;
                case 'safety-report-button': 
                    const locationInput = document.getElementById('location-input');
                    const householdType = document.getElementById('household-type');
                    generateSafetyReport(locationInput.value, householdType.value); 
                    break;
                case 'map-select-button': enterPinMode(); break;
                case 'gps-button': getCurrentLocation(); break;
                case 'drone-request-button': handleDroneRequest(); break;
                case 'power-outage-button': generatePowerOutageReport(); break;
                case 'drone-future-button': generateDroneFutureReport(); break;
                case 'transit-advice-button': generateTransitAdvice(); break;
                case 'add-map-note-button':
                    showModal('情報共有', `
                        <p>地図上をクリックして情報を追加してください。</p>
                        <div class="space-y-2">
                            <div>
                                <label for="note-type">情報の種類:</label>
                                <select id="note-type" class="border rounded p-1">
                                    <option value="danger">危険箇所 ⚠️</option>
                                    <option value="support">支援拠点 🤝</option>
                                    <option value="supply">物資情報 📦</option>
                                </select>
                            </div>
                            <div>
                                <label for="note-comment">コメント:</label>
                                <input type="text" id="note-comment" class="border rounded p-1 w-full" placeholder="例：この先の橋が通行止めです">
                            </div>
                            <button id="submit-note" class="bg-blue-500 text-white p-2 rounded">追加</button>
                        </div>
                    `);
                    document.getElementById('submit-note').onclick = () => {
                         map.once('click', (e) => {
                            const type = document.getElementById('note-type').value;
                            const comment = document.getElementById('note-comment').value;
                            const icons = { danger: '⚠️', support: '🤝', supply: '📦' };
                            L.marker(e.latlng, { icon: L.divIcon({className: 'text-2xl', html: icons[type]}) })
                                .addTo(notesLayer)
                                .bindPopup(`<strong>${type}</strong><br>${comment}`);
                        });
                        alert("地図をクリックして情報を追加してください。");
                        modalContainer.innerHTML = '';
                    };
                    break;
            }
        });
        
        document.getElementById('mode-toggle-button').addEventListener('click', () => {
            const isWorld = currentMode === 'japan';
            switchMode(isWorld ? 'world' : 'japan');
        });

        // --- Initial Load ---
        switchMode('japan'); // Start with Japan mode as requested
        fetchTectonicPlates();
    });
    </script>
</body>
</html>
