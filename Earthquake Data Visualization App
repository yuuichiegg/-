<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çµ±åˆç‰ˆ åœ°éœ‡æƒ…å ±ãƒ“ãƒ¥ãƒ¼ã‚¢ (ç·åˆé˜²ç½AIç‰ˆ) - v6.0</title>
    
    <!-- Leaflet.js CSS and Script -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles */
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100vw; }
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        .plate-tooltip { background-color: rgba(0, 0, 0, 0.7) !important; border: none !important; box-shadow: none !important; color: white !important; font-weight: bold; font-size: 14px; padding: 4px 8px !important; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 1rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Modal styles with animation */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-container {
            background-color: white; padding: 0; border-radius: 0.5rem;
            width: 90%; max-width: 500px; max-height: 85vh;
            display: flex; flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .modal-overlay.visible .modal-container { transform: scale(1); }
        .modal-header { flex-shrink: 0; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; cursor: move; }
        .modal-body { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        .modal-footer { flex-shrink: 0; text-align: right; padding: 1rem 1.5rem; border-top: 1px solid #e5e7eb; }
        .modal-container h2 { font-size: 1.5rem; font-weight: bold; }
        .modal-container h3 { font-size: 1.2rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .modal-container p, .modal-container ul { font-size: 0.9rem; line-height: 1.8; margin-bottom: 1rem; }
        .modal-container li { margin-left: 1.5rem; list-style-type: disc; }
        
        /* Floating Toolbox */
        #toolbox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            border-radius: 999px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 8px;
        }
        .tool-button {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .tool-button:hover { background-color: #e5e7eb; transform: translateY(-2px); }
        .tool-button svg { width: 24px; height: 24px; }
        
        .map-pin-mode { cursor: crosshair !important; }
        #drone-dashboard {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 500;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            width: 280px;
            border: 1px solid #ccc;
        }
        #drone-dashboard h4 { font-weight: bold; }
        #mission-log {
            font-family: monospace;
            font-size: 11px;
            background-color: #2d3748;
            color: #a0aec0;
            padding: 8px;
            border-radius: 4px;
            height: 100px;
            overflow-y: auto;
            margin-top: 8px;
        }
        .drone-icon { transition: all 1s linear; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="map-container" class="w-screen h-screen relative">
        <div id="map"></div>
        <div id="drone-dashboard" class="hidden"></div>
    </div>
    
    <div id="toolbox">
        <button id="mode-toggle-button" class="tool-button" title="ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿"></button>
        <button id="filter-button" class="tool-button" title="ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.572a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" /></svg>
        </button>
        <button id="ai-tools-button" class="tool-button" title="AIé˜²ç½ãƒ„ãƒ¼ãƒ«">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM18 15.75l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 18l-1.035.259a3.375 3.375 0 00-2.456 2.456L18 21.75l-.259-1.035a3.375 3.375 0 00-2.456-2.456L14.25 18l1.035-.259a3.375 3.375 0 002.456-2.456L18 15.75z" /></svg>
        </button>
        <button id="info-share-button" class="tool-button" title="æƒ…å ±å…±æœ‰">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        </button>
        <button id="drone-request-button" class="tool-button" title="ãƒ‰ãƒ­ãƒ¼ãƒ³æ”¯æ´è¦è«‹">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
        </button>
    </div>

    <!-- Modals -->
    <div id="modal-container"></div>

    <!-- Main application logic -->
    <script type="module">
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants and Global Variables ---
        const USGS_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson';
        const USGS_DISASTER_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson';
        const P2P_API_BASE_URL = 'https://api.p2pquake.net/v2/history?codes=551&limit=';
        const TECTONIC_PLATES_URL = 'https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_plates.json';
        
        let currentMode = 'japan';
        let allEarthquakeData = [];
        let filteredEarthquakeData = [];
        let quakeMarkers = {};
        let isApiCallInProgress = false;
        let userCoords = null;
        let droneAnimationId = null;

        // --- DOM Elements ---
        const modalContainer = document.getElementById('modal-container');
        const droneDashboard = document.getElementById('drone-dashboard');

        // --- Leaflet Map Initialization ---
        const map = L.map('map');
        const quakeLayer = L.layerGroup().addTo(map);
        const platesLayer = L.layerGroup();
        const tsunamiLayer = L.layerGroup().addTo(map);
        const notesLayer = L.layerGroup().addTo(map);
        const droneLayer = L.layerGroup().addTo(map);
        const gsiTile = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
            attribution: "<a href='https://maps.gsi.go.jp/development/ichiran.html' target='_blank'>åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>"
        }).addTo(map);
        const baseMaps = { "åœ°ç†é™¢ã‚¿ã‚¤ãƒ«": gsiTile };
        const overlayMaps = { "åœ°éœ‡æƒ…å ±": quakeLayer, "ãƒ—ãƒ¬ãƒ¼ãƒˆ": platesLayer, "æ´¥æ³¢æµ¸æ°´äºˆæ¸¬": tsunamiLayer, "å…±æœ‰æƒ…å ±": notesLayer, "ãƒ‰ãƒ­ãƒ¼ãƒ³": droneLayer };
        L.control.layers(baseMaps, overlayMaps).addTo(map);
        
        // --- Gemini API Call ---
        async function callGeminiApi(prompt) {
            setApiButtonsState(true);
            const apiKey = ""; // Handled by Canvas
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) return result.candidates[0].content.parts[0].text;
                else throw new Error('ç„¡åŠ¹ãªAPIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã§ã™ã€‚');
            } catch (error) {
                console.error("Gemini API Error:", error);
                return `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`;
            } finally { setApiButtonsState(false); }
        }

        // --- Feature Functions ---
        async function generateAnalysis() {
            showModal('âœ¨ AIã«ã‚ˆã‚‹åˆ†æã¨è¦‹é€šã—', '<div class="spinner"></div>');
            if (filteredEarthquakeData.length === 0) { 
                updateModalContent('<p>åˆ†æå¯¾è±¡ã®åœ°éœ‡ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>'); return;
            }
            const largestQuake = filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]);
            const dataSummary = `æœ€å¤§åœ°éœ‡: M${largestQuake.earthquake.hypocenter.magnitude.toFixed(1)} at ${largestQuake.displayPlace}. åœ°éœ‡ä»¶æ•°: ${filteredEarthquakeData.length}.`;
            const prompt = `ã‚ãªãŸã¯å†·é™ã§ä¿¡é ¼ã§ãã‚‹åœ°éœ‡å­¦è€…ã§ã™ã€‚ä»¥ä¸‹ã®åœ°éœ‡ãƒ‡ãƒ¼ã‚¿æ¦‚è¦ã‚’åŸºã«ã€ä¸€èˆ¬å¸‚æ°‘å‘ã‘ã®ç°¡æ½”ãªåˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚ãƒ¬ãƒãƒ¼ãƒˆã«ã¯ä»¥ä¸‹ã®è¦ç´ ã‚’å«ã‚ã¦ãã ã•ã„ã€‚1. **æ´»å‹•ã®æ¦‚è¦**: æœ€å¤§åœ°éœ‡ã‚„æ´»ç™ºãªåœ°åŸŸã«ã¤ã„ã¦è¨€åŠã€‚2. **åœ°è³ªå­¦çš„èƒŒæ™¯**: ãƒ—ãƒ¬ãƒ¼ãƒˆã®å‹•ããªã©ã€åœ°éœ‡ã®ç™ºç”Ÿãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã‚’ç°¡å˜ã«è§£èª¬ã€‚3. **ä»Šå¾Œã®è¦‹é€šã—**: ç‰¹å®šã®äºˆæ¸¬ã¯ã›ãšã€ä¸€èˆ¬çš„ãªæ³¨æ„å–šèµ·ï¼ˆä¾‹ï¼šä½™éœ‡ã®å¯èƒ½æ€§ï¼‰ã«ç•™ã‚ã‚‹ã€‚4. **é˜²ç½ã¸ã®å‘¼ã³ã‹ã‘**: ãƒã‚¸ãƒ†ã‚£ãƒ–ã‹ã¤å…·ä½“çš„ã«ã€æ—¥é ƒã®å‚™ãˆã®é‡è¦æ€§ã‚’è¨´ãˆã‚‹ã€‚å…¨ä½“ã‚’Markdownå½¢å¼ã§ã€è¦ªã—ã¿ã‚„ã™ãã€ã‹ã¤æ¨©å¨ã‚’æãªã‚ãªã„ãƒˆãƒ¼ãƒ³ã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚ãƒ‡ãƒ¼ã‚¿æ¦‚è¦: ${dataSummary}`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateSafetyReport(location, household) {
            if (!location) { 
                showModal('ã‚¨ãƒ©ãƒ¼', '<p>å ´æ‰€ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>');
                return;
            }
            showModal('âœ¨ MYé˜²ç½ãƒ¬ãƒãƒ¼ãƒˆ', '<div class="spinner"></div>');
            const dataSummary = `ç¾åœ¨ã®åœ°éœ‡æ´»å‹•ã®æœ€å¤§è¦æ¨¡ã¯M${filteredEarthquakeData.reduce((max, q) => Math.max(max, q.earthquake.hypocenter.magnitude), 0).toFixed(1)}ã§ã™ã€‚`;
            const prompt = `ã‚ãªãŸã¯åœ°åŸŸã®é˜²ç½ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€Œ${location}ã€ã«ä½ã‚“ã§ãŠã‚Šã€ä¸–å¸¯æ§‹æˆã¯ã€Œ${household}ã€ã§ã™ã€‚ç¾åœ¨ã®åœ°éœ‡æ´»å‹•ï¼ˆ${dataSummary}ï¼‰ã‚’è¸ã¾ãˆã€ãã®åœ°åŸŸã¨ä¸–å¸¯æ§‹æˆã«ç‰¹åŒ–ã—ãŸãƒ‘ãƒ¼ã‚½ãƒŠãƒ«ãªé˜²ç½ãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚ãƒ¬ãƒãƒ¼ãƒˆã«ã¯ä»¥ä¸‹ã®è¦ç´ ã‚’å«ã‚ã¦ãã ã•ã„ã€‚1. **åœ°åŸŸç‰¹æ€§ã®è€ƒæ…®**: ${location}ã®åœ°ç†çš„ç‰¹å¾´ï¼ˆä¾‹ï¼šæ²¿å²¸éƒ¨ã€éƒ½å¸‚éƒ¨ã€å±±é–“éƒ¨ãªã©ï¼‰ã‚’è€ƒæ…®ã—ãŸå…·ä½“çš„ãªãƒªã‚¹ã‚¯ã«ã¤ã„ã¦è¨€åŠã€‚2. **ä¸–å¸¯æ§‹æˆã«åˆã‚ã›ãŸå‚™ãˆ**: ã€Œ${household}ã€ã«ç‰¹ã«é‡è¦ãªã€å…·ä½“çš„ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã€‚3. **å‚™è“„å“ãƒªã‚¹ãƒˆ**: ä¸–å¸¯æ§‹æˆã«åˆã‚ã›ãŸéå¸¸ç”¨æŒã¡å‡ºã—è¢‹ã®ä¸­èº«ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§ææ¡ˆã€‚4. **ç‰©è³‡ç¢ºä¿ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹**: ç½å®³æ™‚ã«æ°´ã€é£Ÿæ–™ã€ãƒãƒƒãƒ†ãƒªãƒ¼ãªã©ã®ç‰©è³‡ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®å…·ä½“çš„ãªã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ææ¡ˆã—ã¦ãã ã•ã„ã€‚5. **å¿ƒã®ã‚±ã‚¢**: ä¸å®‰ã‚’ç…½ã‚‰ãšã€å‚™ãˆã‚‹ã“ã¨ã®é‡è¦æ€§ã‚’ãƒã‚¸ãƒ†ã‚£ãƒ–ã«ä¼ãˆã‚‹ã€‚å…¨ä½“ã‚’Markdownå½¢å¼ã§ã€è¦ªã—ã¿ã‚„ã™ãã€å…·ä½“çš„ã§å½¹ç«‹ã¤å†…å®¹ã«ã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePreparednessTips() {
            showModal('ğŸ’¡ äº‹å‰ã®å‚™ãˆ (AIé˜²ç½ã‚¢ãƒ‰ãƒã‚¤ã‚¶ãƒ¼)', '<div class="spinner"></div>');
            const prompt = `ã‚ãªãŸã¯çµŒé¨“è±Šå¯Œãªé˜²ç½ã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆã§ã™ã€‚åœ°éœ‡ãŒç™ºç”Ÿã™ã‚‹å‰ã«å®¶åº­ã§ã§ãã‚‹äºˆé˜²ç­–ã‚„ã€é˜²ç½è¨ˆç”»ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ã„ãã¤ã‹ææ¡ˆã—ã¦ãã ã•ã„ã€‚å®¶å…·ã®å›ºå®šæ–¹æ³•ã€å‚™è“„å“ã®é¸ã³æ–¹ã€å®¶æ—ã¨ã®é€£çµ¡æ–¹æ³•ã®ç¢ºèªãªã©ã€èª­è€…ãŒã™ãã«è¡Œå‹•ã«ç§»ã›ã‚‹ã‚ˆã†ãªå…·ä½“çš„ã§å®Ÿè·µçš„ãªã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’Markdownå½¢å¼ã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePowerOutageReport() {
            const locationInput = document.getElementById('location-input');
            if (!locationInput || !locationInput.value) {
                showModal('ã‚¨ãƒ©ãƒ¼', '<p>åœé›»ãƒªã‚¹ã‚¯åˆ†æã«ã¯ã€ã¾ãšã€ŒMYé˜²ç½ãƒ¬ãƒãƒ¼ãƒˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§å ´æ‰€ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>');
                return;
            }
            showModal('ğŸ’¡ åœé›»ãƒªã‚¹ã‚¯åˆ†æ (AI)', '<div class="spinner"></div>');
            const largestQuake = filteredEarthquakeData.length > 0 ? filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]) : null;
            const prompt = `ã‚ãªãŸã¯é›»åŠ›ã‚¤ãƒ³ãƒ•ãƒ©ã«è©³ã—ã„é˜²ç½å°‚é–€å®¶ã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã€Œ${locationInput.value}ã€ã«ã„ã¾ã™ã€‚ç¾åœ¨ã€æœ€å¤§M${largestQuake ? largestQuake.earthquake.hypocenter.magnitude.toFixed(1) : 'ä¸æ˜'}ã®åœ°éœ‡ãŒè¦³æ¸¬ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã®çŠ¶æ³ã‚’è¸ã¾ãˆã€ä»¥ä¸‹ã®ç‚¹ã«ã¤ã„ã¦ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ãã ã•ã„ã€‚
            1. **åœé›»ã®å¯èƒ½æ€§**: ã“ã®è¦æ¨¡ã®åœ°éœ‡ã§ã€${locationInput.value}ã§åœé›»ãŒç™ºç”Ÿã™ã‚‹ä¸€èˆ¬çš„ãªå¯èƒ½æ€§ã¯ï¼Ÿ
            2. **å¾©æ—§ã®è¦‹é€šã—**: ã‚‚ã—åœé›»ã—ãŸå ´åˆã€å¾©æ—§ã«ã¯ã©ã®ãã‚‰ã„ã®æ™‚é–“ãŒã‹ã‹ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã‹ï¼Ÿ
            3. **ä»Šã™ãã§ãã‚‹å¯¾ç­–**: åœé›»ã«å‚™ãˆã¦ã€ä»Šã™ãã§ãã‚‹ã“ã¨ã¯ä½•ã‹ï¼Ÿ(ä¾‹: ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³ã®å……é›»ã€æ‡ä¸­é›»ç¯ã®æº–å‚™ãªã©)
            å°‚é–€çš„ã‹ã¤åˆ†ã‹ã‚Šã‚„ã™ã„è¨€è‘‰ã§ã€Markdownå½¢å¼ã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generateDroneFutureReport() {
            showModal('ğŸ¤– AIã¨èªã‚‹ãƒ‰ãƒ­ãƒ¼ãƒ³ã®æœªæ¥', '<div class="spinner"></div>');
            const prompt = `ã‚ãªãŸã¯ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ã¨ç¤¾ä¼šã®æœªæ¥ã«è©³ã—ã„ã‚¢ãƒŠãƒªã‚¹ãƒˆã§ã™ã€‚ã€Œç½å®³å¯¾ç­–ã«ãŠã‘ã‚‹ãƒ‰ãƒ­ãƒ¼ãƒ³ã®é‡è¦æ€§ã¨ä»Šå¾Œã®å±•æœ›ã€ã¨ã„ã†ãƒ†ãƒ¼ãƒã§ã€ä¸€èˆ¬å‘ã‘ã®è§£èª¬è¨˜äº‹ã‚’åŸ·ç­†ã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®è¦ç´ ã‚’å¿…ãšå«ã‚ã¦ãã ã•ã„ã€‚
            1. **ç¾åœ¨ã®æ´»ç”¨äº‹ä¾‹**: ç‰©è³‡è¼¸é€ã€æƒ…å ±åé›†ã€è¢«ç½è€…æœç´¢ãªã©ã€‚
            2. **æœªæ¥ã®å¯èƒ½æ€§**: 1å¯¾né‹èˆªï¼ˆç¾¤åˆ¶å¾¡ï¼‰ã€AIã«ã‚ˆã‚‹è‡ªå¾‹åˆ¤æ–­ã€æ•‘åŠ©æ´»å‹•ã¸ã®ç›´æ¥å‚åŠ ãªã©ã€ã•ã‚‰ã«é€²ã‚“ã æ´»ç”¨æ–¹æ³•ã€‚
            3. **è§£æ±ºã™ã¹ãèª²é¡Œ**: æ³•æ•´å‚™ã€æ©Ÿä½“æ€§èƒ½ã®å‘ä¸Šï¼ˆãƒãƒƒãƒ†ãƒªãƒ¼ã€ç©è¼‰é‡ï¼‰ã€ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ä¿è­·ã€ç¤¾ä¼šçš„ãªå—å®¹æ€§ãªã©ã€‚
            èª­è€…ãŒæœªæ¥ã«å¸Œæœ›ã‚’æŒã¦ã‚‹ã‚ˆã†ãªã€å‰å‘ããªãƒˆãƒ¼ãƒ³ã§Markdownå½¢å¼ã§è¨˜è¿°ã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateTransitAdvice() {
            showModal('ğŸš— äº¤é€šæ©Ÿé–¢å‘ã‘AIã‚¢ãƒ‰ãƒã‚¤ã‚¹', '<div class="spinner"></div>');
            const prompt = `ã‚ãªãŸã¯ç½å®³å±æ©Ÿç®¡ç†ã®å°‚é–€å®¶ã§ã™ã€‚åœ°éœ‡ç™ºç”Ÿæ™‚ã«ã€æ§˜ã€…ãªäº¤é€šæ©Ÿé–¢ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹äººã€…ï¼ˆé‹è»¢æ‰‹ã‚„ä¹—å®¢ï¼‰ã«å‘ã‘ã¦ã€ãã‚Œãã‚Œã®çŠ¶æ³ã«å¿œã˜ãŸå…·ä½“çš„ã§å®‰å…¨ãªè¡Œå‹•æŒ‡é‡ã‚’ã‚¢ãƒ‰ãƒã‚¤ã‚¹ã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®é …ç›®ã‚’å¿…ãšå«ã‚ã¦ãã ã•ã„ã€‚
            - **è‡ªå‹•è»Šã‚’é‹è»¢ä¸­ã®å ´åˆ**
            - **ãƒã‚¹ã‚„ã‚¿ã‚¯ã‚·ãƒ¼ã«ä¹—è»Šä¸­ã®å ´åˆ**
            - **é‰„é“ï¼ˆé›»è»Šãƒ»æ–°å¹¹ç·šï¼‰ã«ä¹—è»Šä¸­ã®å ´åˆ**
            - **ãƒã‚¤ã‚¯ã‚„è‡ªè»¢è»Šã«ä¹—ã£ã¦ã„ã‚‹å ´åˆ**
            å„é …ç›®ã§ã€ã€Œæºã‚Œã¦ã„ã‚‹æœ€ä¸­ã®è¡Œå‹•ã€ã¨ã€Œæºã‚ŒãŒåã¾ã£ãŸå¾Œã®è¡Œå‹•ã€ã‚’æ˜ç¢ºã«åˆ†ã‘ã¦èª¬æ˜ã—ã¦ãã ã•ã„ã€‚Markdownå½¢å¼ã§ã€ç°¡æ½”ã‹ã¤åˆ†ã‹ã‚Šã‚„ã™ãè¨˜è¿°ã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function handleDroneRequest() {
            const locationInput = document.getElementById('location-input');
            if (!locationInput || !locationInput.value) {
                showModal('ã‚¨ãƒ©ãƒ¼', '<p>ãƒ‰ãƒ­ãƒ¼ãƒ³æ”¯æ´è¦è«‹ã«ã¯ã€ã¾ãšã€ŒMYé˜²ç½ãƒ¬ãƒãƒ¼ãƒˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§å ´æ‰€ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>');
                return;
            }

            const modalId = `modal-drone-${Date.now()}`;
            const modalContent = `
                <p class="text-sm">è¦è«‹å ´æ‰€: <strong>${locationInput.value}</strong></p>
                <p>å¿…è¦ãªç‰©è³‡ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰ï¼š</p>
                <div class="space-y-2 my-4">
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="åŒ»è–¬å“" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">åŒ»è–¬å“ (å¿œæ€¥æ‰‹å½“ã‚»ãƒƒãƒˆãªã©)</span></label>
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="é£Ÿæ–™ãƒ»æ°´" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">é£Ÿæ–™ãƒ»æ°´ (æœ€ä½1æ—¥åˆ†)</span></label>
                    <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="ãƒãƒƒãƒ†ãƒªãƒ¼" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">ãƒãƒƒãƒ†ãƒªãƒ¼ (ãƒ¢ãƒã‚¤ãƒ«ç”¨)</span></label>
                </div>
                <div class="text-right">
                    <button id="submit-drone-request" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-md hover:bg-sky-700">AIã«ã‚ˆã‚‹ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹</button>
                </div>
                <div id="drone-response-container" class="mt-4"></div>
            `;
            const modalEl = showModal('ğŸš ãƒ‰ãƒ­ãƒ¼ãƒ³æ”¯æ´è¦è«‹ (ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)', modalContent, modalId);
            
            modalEl.querySelector('#submit-drone-request').addEventListener('click', async () => {
                const droneResponseContainer = modalEl.querySelector('.modal-body');
                const selectedSupplies = Array.from(modalEl.querySelectorAll('input[name="drone-supplies"]:checked')).map(cb => cb.value);
                if (selectedSupplies.length === 0) {
                    droneResponseContainer.innerHTML = '<p class="text-red-500">å°‘ãªãã¨ã‚‚1ã¤ã®ç‰©è³‡ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>';
                    return;
                }
                droneResponseContainer.innerHTML = '<div class="spinner"></div>';
                const prompt = `ã‚ãªãŸã¯ç½å®³å¯¾å¿œãƒ‰ãƒ­ãƒ¼ãƒ³ã®é‹ç”¨AIã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‹ã‚‰ä»¥ä¸‹ã®å†…å®¹ã§æ”¯æ´è¦è«‹ãŒã‚ã‚Šã¾ã—ãŸã€‚å¿œç­”ã‚’JSONå½¢å¼ã§ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚
                - **è¦è«‹å ´æ‰€**: ${locationInput.value}
                - **è¦è«‹å ´æ‰€ã®åº§æ¨™**: ${userCoords ? `ç·¯åº¦${userCoords.lat}, çµŒåº¦${userCoords.lng}`: 'ä¸æ˜'}
                - **è¦è«‹ç‰©è³‡**: ${selectedSupplies.join(', ')}
                - **ç¾åœ¨ã®çŠ¶æ³**: å¤§è¦æ¨¡ãªåœ°éœ‡ãŒç™ºç”Ÿã—ã€äº¤é€šç¶²ã«å½±éŸ¿ãŒå‡ºã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚

                å¿œç­”JSONã®ä»•æ§˜:
                {
                  "departurePointName": "ï¼ˆ${locationInput.value} å†…ã®å…·ä½“çš„ãªå‡ºç™ºæ‹ ç‚¹åã€‚å¸‚å½¹æ‰€ã€å¤§ããªå…¬åœ’ãªã©ï¼‰",
                  "departurePointLat": ï¼ˆå‡ºç™ºåœ°ç‚¹ã®ç·¯åº¦ï¼‰,
                  "departurePointLng": ï¼ˆå‡ºç™ºåœ°ç‚¹ã®çµŒåº¦ï¼‰,
                  "estimatedFlightMinutes": ï¼ˆç¾å®Ÿçš„ãªé£›è¡Œæ™‚é–“ï¼ˆåˆ†ï¼‰ï¼‰,
                  "missionLog": [
                      {"time": 0, "event": "è¦è«‹ã‚’å—ç†ã—ã¾ã—ãŸã€‚ãƒ‰ãƒ­ãƒ¼ãƒ³ã‚’ç™ºé€²æº–å‚™ä¸­ã§ã™ã€‚"},
                      {"time": 1, "event": "ãƒ‰ãƒ­ãƒ¼ãƒ³ãŒæ‹ ç‚¹ï¼ˆ${locationInput.value}é˜²ç½ã‚»ãƒ³ã‚¿ãƒ¼ï¼‰ã‹ã‚‰é›¢é™¸ã—ã¾ã—ãŸã€‚"},
                      {"time": 5, "event": "é«˜åº¦100mã€é€Ÿåº¦50km/hã§å®‰å®šé£›è¡Œä¸­ã€‚"},
                      {"time": 8, "event": "ä»–ã®ç·Šæ€¥è»Šä¸¡ã¨ã®é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«ãƒ«ãƒ¼ãƒˆã‚’èª¿æ•´ã—ã¾ã™ã€‚"},
                      {"time": 12, "event": "ç›®çš„åœ°ã¾ã§ã‚ã¨ã‚ãšã‹ã§ã™ã€‚å®‰å…¨ãªå ´æ‰€ã§å¾…æ©Ÿã—ã¦ãã ã•ã„ã€‚"}
                  ],
                  "narrative": "ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®å¿œç­”ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€‚è¦è«‹å—ç†ã€ç™ºé€²ã€åˆ°ç€äºˆå®šã€é£›è¡ŒçµŒè·¯ã€å—ã‘å–ã‚Šæ™‚ã®æ³¨æ„ã€å…è²¬äº‹é …ã‚’å«ã‚€Markdownå½¢å¼ã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰"
                }`;
                const resultText = await callGeminiApi(prompt);
                try {
                    const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) throw new Error("AIã®å¿œç­”ã«JSONãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
                    const jsonString = jsonMatch[0];
                    const resultJson = JSON.parse(jsonString);
                    
                    const responseHtml = formatTextToHtml(resultJson.narrative);
                    droneResponseContainer.innerHTML = `<div id="drone-map"></div>${responseHtml}`;
                    
                    if(userCoords) {
                        const startPoint = [resultJson.departurePointLat, resultJson.departurePointLng];
                        const endPoint = [userCoords.lat, userCoords.lng];
                        const droneMap = L.map('drone-map');
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(droneMap);
                        initializeDroneMap(droneMap, startPoint, endPoint, resultJson.estimatedFlightMinutes, resultJson.missionLog);
                    }
                } catch(e) {
                    console.error("Failed to parse drone response JSON", e);
                    droneResponseContainer.innerHTML = `<p class="text-red-500">AIã‹ã‚‰ã®å¿œç­”ã‚’è§£æã§ãã¾ã›ã‚“ã§ã—ãŸã€‚é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã§è¡¨ç¤ºã—ã¾ã™ã€‚</p>${formatTextToHtml(resultText)}`;
                }
            });
        }

        async function getHistoricalContext(quake) {
            showModal('âœ¨ AIã«ã‚ˆã‚‹åœ°åŸŸã®åœ°éœ‡å±¥æ­´åˆ†æ', '<div class="spinner"></div>');
            const prompt = `ã‚ãªãŸã¯åœ°éœ‡ã®æ­´å²ã«è©³ã—ã„å°‚é–€å®¶ã§ã™ã€‚ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰${quake.earthquake.hypocenter.magnitude.toFixed(1)}ã®åœ°éœ‡ãŒã€Œ${quake.displayPlace}ã€ã§ç™ºç”Ÿã—ã¾ã—ãŸã€‚ã“ã®åœ°åŸŸã«ãŠã‘ã‚‹éå»ã®ç‰¹ç­†ã™ã¹ãåœ°éœ‡æ´»å‹•ã‚„ã€ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ†ã‚¯ãƒˆãƒ‹ã‚¯ã‚¹ã®è¦³ç‚¹ã‹ã‚‰ã®åœ°è³ªå­¦çš„ãªèƒŒæ™¯ã«ã¤ã„ã¦ã€ä¸€èˆ¬ã®äººã«ã‚‚åˆ†ã‹ã‚Šã‚„ã™ãç°¡æ½”ã«è§£èª¬ã—ã¦ãã ã•ã„ã€‚ã“ã®åœ°åŸŸã¯åœ°éœ‡ãŒå¤šã„ã“ã¨ã§çŸ¥ã‚‰ã‚Œã¦ã„ã¾ã™ã‹ï¼Ÿã‚‚ã—ã‚ãªãŸã®çŸ¥è­˜ãƒ™ãƒ¼ã‚¹ã«è‘—åãªéå»ã®åœ°éœ‡ãŒã‚ã‚Œã°ã€ãã‚Œã«è¨€åŠã—ã¦ãã ã•ã„ã€‚`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        function handleTsunamiSimulation(quake) {
            if (!quake.earthquake.tsunami) {
                showModal('æ´¥æ³¢æƒ…å ±', '<p>ã“ã®åœ°éœ‡ã«ã‚ˆã‚‹æ´¥æ³¢ã®å¿ƒé…ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>');
                return;
            }
            if (!userCoords) {
                showModal('ã‚¨ãƒ©ãƒ¼', '<p>ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¯ã€ã¾ãšã€ŒMYé˜²ç½ãƒ¬ãƒãƒ¼ãƒˆã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã‚ãªãŸã®å ´æ‰€ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>');
                return;
            }

            tsunamiLayer.clearLayers();
            
            // Simulate inundation zone
            const center = [quake.earthquake.hypocenter.latitude, quake.earthquake.hypocenter.longitude];
            const radius = 10000 + quake.earthquake.hypocenter.magnitude * 2000; // Simplified radius
            const circle = L.circle(center, {
                color: 'blue',
                fillColor: '#3388ff',
                fillOpacity: 0.3,
                radius: radius
            }).addTo(tsunamiLayer);

            // Simulate evacuation route
            const userLatLng = L.latLng(userCoords.lat, userCoords.lng);
            // Simple logic: find a point away from the quake epicenter
            const bearing = map.project(center).subtract(map.project(userLatLng)).angle();
            const evacuationPoint = L.latLng(
                userLatLng.lat + Math.sin(bearing) * 0.05, // Approx 5km away
                userLatLng.lng + Math.cos(bearing) * 0.05
            );
            
            const route = L.polyline([userLatLng, evacuationPoint], {color: 'green', dashArray: '5, 5'}).addTo(tsunamiLayer);
            const shelterIcon = L.divIcon({className: 'text-4xl', html: 'ğŸ«'});
            L.marker(evacuationPoint, {icon: shelterIcon}).addTo(tsunamiLayer).bindTooltip("é«˜å°é¿é›£å ´æ‰€ (ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³)");

            map.fitBounds(L.featureGroup([circle, route]).getBounds().pad(0.2));
            
            showModal('æ´¥æ³¢ãƒ»é¿é›£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³', '<div class="analysis-disclaimer"><strong>ã€é‡è¦ã€‘</strong>ã“ã‚Œã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚å®Ÿéš›ã®æµ¸æ°´åŸŸã‚„é¿é›£çµŒè·¯ã¨ã¯ç•°ãªã‚Šã¾ã™ã€‚å®Ÿéš›ã®é¿é›£ã¯ã€å¿…ãšè‡ªæ²»ä½“ã®æŒ‡ç¤ºã«å¾“ã£ã¦ãã ã•ã„ã€‚</div><p>åœ°å›³ä¸Šã«é’ã§æƒ³å®šæµ¸æ°´åŸŸã€ç·‘ã®ç ´ç·šã§é«˜å°ã¸ã®é¿é›£ãƒ«ãƒ¼ãƒˆï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰ã‚’è¡¨ç¤ºã—ã¾ã—ãŸã€‚</p>');
        }

        function switchMode(newMode) {
            if (currentMode === newMode && allEarthquakeData.length > 0) return;
            currentMode = newMode;
            map.setView(newMode === 'world' ? [20, 0] : [36, 138], newMode === 'world' ? 2 : 5);
            setTimeout(() => map.invalidateSize(), 0);
            allEarthquakeData = [];
            filteredEarthquakeData = [];
            fetchData();
        }

        function fetchData() {
            if (currentMode === 'world') {
                fetchWorldData();
            } else {
                fetchJapanData();
            }
        }

        function applyFilters() {
            const magFilter = document.getElementById('mag-filter');
            const minMag = magFilter ? parseFloat(magFilter.value) : 0;
            
            filteredEarthquakeData = allEarthquakeData.filter(quake => quake.earthquake.hypocenter.magnitude >= minMag);
            
            if (currentMode === 'world') {
                const regionFilter = document.getElementById('region-filter');
                const selectedRegion = regionFilter ? regionFilter.value : 'all';
                if (selectedRegion !== 'all') {
                    filteredEarthquakeData = filteredEarthquakeData.filter(quake => quake.region === selectedRegion);
                }
            }
            renderEarthquakes(filteredEarthquakeData);
        }

        function renderEarthquakes(data) {
            const listElement = document.getElementById('earthquake-list');
            const quakeCount = document.getElementById('quake-count');
            
            quakeLayer.clearLayers();
            quakeMarkers = {};

            if (listElement) listElement.innerHTML = '';
            if (quakeCount) quakeCount.textContent = data.length;

            if (!data || data.length === 0) {
                if(listElement) listElement.innerHTML = '<li class="p-4 text-center text-gray-500">è¡¨ç¤ºã§ãã‚‹åœ°éœ‡æƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</li>'; 
                return;
            }
            
            data.sort((a, b) => b.time - a.time);
            
            data.forEach(quake => {
                const { hypocenter, tsunami, shindo } = quake.earthquake;
                const { latitude, longitude, magnitude, depth } = hypocenter;
                const { displayPlace, displayTime } = quake;
                const quakeId = quake.id;
                const radius = Math.pow(1.8, magnitude) * (currentMode === 'world' ? 3000 : 500);
                const fillColor = currentMode === 'world' ? getMagnitudeColor(magnitude) : getJmaShindoColor(shindo.value);
                const defaultStyle = { color: "#111", weight: 1, fillColor: fillColor, fillOpacity: 0.7, radius: radius };
                const highlightStyle = { color: "#000000", weight: 4 };
                const circle = L.circle([latitude, longitude], defaultStyle);
                const shindoLabel = shindo.type === 'JMA' ? 'æ°—è±¡åºéœ‡åº¦' : 'MMIéœ‡åº¦';
                const shindoValue = shindo.value || 'æƒ…å ±ãªã—';
                
                const popupContent = document.createElement('div');
                popupContent.className = 'font-sans space-y-2';
                popupContent.innerHTML = `<strong class="text-base">ç™ºç”Ÿæ™‚åˆ»:</strong> ${displayTime}<br><strong class="text-base">éœ‡æºåœ°:</strong> ${displayPlace}<br><strong class="text-base">ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰:</strong> ${magnitude.toFixed(1)}<br><strong class="text-base">æ·±ã•:</strong> ${depth.toFixed(1)} km<br><strong class="text-base">${shindoLabel}:</strong> ${shindoValue}<br><strong class="text-base">æ´¥æ³¢ã®å¯èƒ½æ€§:</strong> ${tsunami ? 'ã‚ã‚Š' : 'ãªã—'}`;
                
                const historyButton = document.createElement('button');
                historyButton.className = 'w-full text-sm bg-purple-600 text-white font-bold py-1 px-2 rounded-md hover:bg-purple-700 transition-colors';
                historyButton.innerHTML = 'âœ¨ ã“ã®åœ°åŸŸã®éå»ã®æ´»å‹•ã‚’AIåˆ†æ';
                historyButton.onclick = () => getHistoricalContext(quake);
                
                const tsunamiButton = document.createElement('button');
                tsunamiButton.className = 'w-full text-sm bg-cyan-600 text-white font-bold py-1 px-2 rounded-md hover:bg-cyan-700 transition-colors';
                tsunamiButton.innerHTML = 'ğŸŒŠ æ´¥æ³¢ãƒ»é¿é›£ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³';
                tsunamiButton.onclick = () => handleTsunamiSimulation(quake);

                popupContent.appendChild(historyButton);
                popupContent.appendChild(tsunamiButton);
                circle.bindPopup(popupContent);

                quakeLayer.addLayer(circle);
                
                if (listElement) {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-3 border rounded-lg shadow-sm list-item-hover transition-colors duration-200';
                    listItem.innerHTML = `<div class="font-semibold text-gray-800">${displayPlace} ${tsunami ? 'ğŸŒŠ' : ''}</div><div class="text-sm text-gray-600">${displayTime}</div><div class="flex flex-wrap justify-between items-center mt-2 text-sm gap-x-4 gap-y-1"><span class="font-bold px-2 py-1 rounded-md" style="background-color:${fillColor}; color: ${isDarkColor(fillColor) ? 'white' : 'black'}">ãƒã‚°ãƒ‹ãƒãƒ¥ãƒ¼ãƒ‰ ${magnitude.toFixed(1)}</span><span>æ·±ã•: ${depth.toFixed(1)} km</span><span>${shindoLabel}: ${shindoValue}</span></div>`;
                    listItem.addEventListener('mouseover', () => { circle.setStyle(highlightStyle).bringToFront(); });
                    listItem.addEventListener('mouseout', () => { circle.setStyle(defaultStyle); });
                    listItem.addEventListener('click', () => { map.flyTo([latitude, longitude], 6); circle.openPopup(); });
                    listElement.appendChild(listItem);
                }
                quakeMarkers[quakeId] = { circle };
            });
        }
        
        async function fetchTectonicPlates() {
            const plateNameMap = { "African": "ã‚¢ãƒ•ãƒªã‚«ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Antarctic": "å—æ¥µãƒ—ãƒ¬ãƒ¼ãƒˆ", "Arabian": "ã‚¢ãƒ©ãƒ“ã‚¢ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Australian": "ã‚ªãƒ¼ã‚¹ãƒˆãƒ©ãƒªã‚¢ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Caribbean": "ã‚«ãƒªãƒ–ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Cocos": "ã‚³ã‚³ã‚¹ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Eurasian": "ãƒ¦ãƒ¼ãƒ©ã‚·ã‚¢ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Indian": "ã‚¤ãƒ³ãƒ‰ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Juan de Fuca": "ãƒ•ã‚¡ãƒ³ãƒ‡ãƒ•ã‚«ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Nazca": "ãƒŠã‚¹ã‚«ãƒ—ãƒ¬ãƒ¼ãƒˆ", "North American": "åŒ—ç±³ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Okhotsk": "ã‚ªãƒ›ãƒ¼ãƒ„ã‚¯ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Pacific": "å¤ªå¹³æ´‹ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Philippine Sea": "ãƒ•ã‚£ãƒªãƒ”ãƒ³æµ·ãƒ—ãƒ¬ãƒ¼ãƒˆ", "Scotia": "ã‚¹ã‚³ã‚·ã‚¢ãƒ—ãƒ¬ãƒ¼ãƒˆ", "South American": "å—ç±³ãƒ—ãƒ¬ãƒ¼ãƒˆ" };
            try {
                const response = await fetch(TECTONIC_PLATES_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const platesData = await response.json();
                L.geoJSON(platesData, { style: { color: "#ff7800", weight: 2, opacity: 0.65, fillColor: "#ff7800", fillOpacity: 0.1 }, onEachFeature: (feature, layer) => { if (feature.properties && feature.properties.PlateName) { const displayName = plateNameMap[feature.properties.PlateName] || feature.properties.PlateName; layer.bindTooltip(displayName, { permanent: false, direction: 'center', className: 'plate-tooltip' }); } } }).addTo(platesLayer);
            } catch (error) { console.error('Failed to fetch tectonic plates data:', error); }
        }

        async function fetchWorldData(isDisaster = false) {
            const url = isDisaster ? USGS_DISASTER_API_URL : USGS_API_URL;
            const countryNameMap = { "CA": "ã‚«ãƒªãƒ•ã‚©ãƒ«ãƒ‹ã‚¢", "California": "ã‚«ãƒªãƒ•ã‚©ãƒ«ãƒ‹ã‚¢", "Alaska": "ã‚¢ãƒ©ã‚¹ã‚«", "Hawaii": "ãƒãƒ¯ã‚¤", "Indonesia": "ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢", "Japan": "æ—¥æœ¬", "Philippines": "ãƒ•ã‚£ãƒªãƒ”ãƒ³", "Fiji": "ãƒ•ã‚£ã‚¸ãƒ¼", "Chile": "ãƒãƒª", "Mexico": "ãƒ¡ã‚­ã‚·ã‚³", "New Zealand": "ãƒ‹ãƒ¥ãƒ¼ã‚¸ãƒ¼ãƒ©ãƒ³ãƒ‰", "Russia": "ãƒ­ã‚·ã‚¢", "Papua New Guinea": "ãƒ‘ãƒ—ã‚¢ãƒ‹ãƒ¥ãƒ¼ã‚®ãƒ‹ã‚¢", "Tonga": "ãƒˆãƒ³ã‚¬", "Vanuatu": "ãƒãƒŒã‚¢ãƒ„", "Solomon Islands": "ã‚½ãƒ­ãƒ¢ãƒ³è«¸å³¶", "Taiwan": "å°æ¹¾", "China": "ä¸­å›½", "Turkey": "ãƒˆãƒ«ã‚³", "Greece": "ã‚®ãƒªã‚·ãƒ£", "Italy": "ã‚¤ã‚¿ãƒªã‚¢", "Iran": "ã‚¤ãƒ©ãƒ³", "Peru": "ãƒšãƒ«ãƒ¼", "Argentina": "ã‚¢ãƒ«ã‚¼ãƒ³ãƒãƒ³", "Colombia": "ã‚³ãƒ­ãƒ³ãƒ“ã‚¢", "Ecuador": "ã‚¨ã‚¯ã‚¢ãƒ‰ãƒ«", "Guatemala": "ã‚°ã‚¢ãƒ†ãƒãƒ©", "Costa Rica": "ã‚³ã‚¹ã‚¿ãƒªã‚«", "Nicaragua": "ãƒ‹ã‚«ãƒ©ã‚°ã‚¢", "El Salvador": "ã‚¨ãƒ«ã‚µãƒ«ãƒãƒ‰ãƒ«", "Honduras": "ãƒ›ãƒ³ã‚¸ãƒ¥ãƒ©ã‚¹", "Panama": "ãƒ‘ãƒŠãƒ", "Puerto Rico": "ãƒ—ã‚¨ãƒ«ãƒˆãƒªã‚³", "Dominican Republic": "ãƒ‰ãƒŸãƒ‹ã‚«å…±å’Œå›½", "Iceland": "ã‚¢ã‚¤ã‚¹ãƒ©ãƒ³ãƒ‰", "Portugal": "ãƒãƒ«ãƒˆã‚¬ãƒ«", "Spain": "ã‚¹ãƒšã‚¤ãƒ³", "India": "ã‚¤ãƒ³ãƒ‰", "Pakistan": "ãƒ‘ã‚­ã‚¹ã‚¿ãƒ³", "Afghanistan": "ã‚¢ãƒ•ã‚¬ãƒ‹ã‚¹ã‚¿ãƒ³", "Kyrgyzstan": "ã‚­ãƒ«ã‚®ã‚¹", "Tajikistan": "ã‚¿ã‚¸ã‚­ã‚¹ã‚¿ãƒ³", "Uzbekistan": "ã‚¦ã‚ºãƒ™ã‚­ã‚¹ã‚¿ãƒ³" };
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                const regions = new Set();
                allEarthquakeData = data.features.map(feature => {
                    const place = feature.properties.place; const latitude = feature.geometry.coordinates[1]; const longitude = feature.geometry.coordinates[0];
                    let region = place, japanesePlace = place, isJapan = false;
                    if (place && place.includes(',')) { const parts = place.split(','); region = parts[parts.length - 1].trim(); if (region === "Japan") isJapan = true; const translatedRegion = countryNameMap[region] || region; japanesePlace = `${translatedRegion} - ${parts.slice(0, -1).join(',')}`; } else if (place && place.toLowerCase().includes("japan")) { isJapan = true; region = "Japan"; japanesePlace = place; }
                    regions.add(region);
                    const isNearJapan = latitude >= 20 && latitude <= 46 && longitude >= 122 && longitude <= 154;
                    const displayTime = isNearJapan ? new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (æ—¥æœ¬æ™‚é–“)' : new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'UTC' }) + ' (å”å®šä¸–ç•Œæ™‚)';
                    return { id: feature.id, time: feature.properties.time, region: region, displayPlace: japanesePlace, isJapan: isJapan, displayTime: displayTime, earthquake: { hypocenter: { latitude: latitude, longitude: longitude, depth: feature.geometry.coordinates[2], magnitude: feature.properties.mag }, tsunami: feature.properties.tsunami, shindo: { type: isJapan ? 'JMA' : 'MMI', value: isJapan ? convertMmiToJmaShindo(feature.properties.mmi) : convertMmiToRoman(feature.properties.mmi) } } };
                });
                populateRegionFilter(regions); applyFilters();
            } catch (error) { console.error('Failed to fetch world data:', error); }
        }
        
        async function fetchJapanData(limit = 100) {
            try {
                const response = await fetch(P2P_API_BASE_URL + limit);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                allEarthquakeData = data.map(q => {
                    const { earthquake, id, time } = q;
                    return { id: id, time: new Date(time).getTime(), region: 'Japan', displayPlace: earthquake.hypocenter.name, isJapan: true, displayTime: new Date(time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (æ—¥æœ¬æ™‚é–“)', earthquake: { hypocenter: { latitude: parseFloat(earthquake.hypocenter.latitude), longitude: parseFloat(earthquake.hypocenter.longitude), depth: parseFloat(earthquake.hypocenter.depth), magnitude: parseFloat(earthquake.hypocenter.magnitude) }, tsunami: earthquake.tsunami?.text.includes('æ´¥æ³¢ã®å¿ƒé…ã¯ã‚ã‚Šã¾ã›ã‚“') === false, shindo: { type: 'JMA', value: convertScale(earthquake.maxScale) } } };
                });
                applyFilters();
            } catch(error) { console.error('Failed to fetch Japan data:', error); }
        }

        function populateRegionFilter(regions) {
            const regionFilter = document.getElementById('region-filter-modal');
            if(!regionFilter) return;
            regionFilter.innerHTML = '<option value="all">ã™ã¹ã¦è¡¨ç¤º</option>';
            const sortedRegions = Array.from(regions).sort();
            sortedRegions.forEach(region => { const option = document.createElement('option'); option.value = region; option.textContent = region; regionFilter.appendChild(option); });
        }
        
        // --- Modal and Policy/Terms Logic ---
        function showModal(title, content, modalId = `modal-${Date.now()}`) {
            const existingModal = document.getElementById(modalId);
            if(existingModal) existingModal.remove();

            const modalEl = document.createElement('div');
            modalEl.id = modalId;
            modalEl.className = 'modal-overlay';
            modalEl.innerHTML = `
                <div class="modal-container">
                    <div class="modal-header">
                        <h2 class="text-2xl font-bold mb-4">${title}</h2>
                    </div>
                    <div class="modal-body">${content}</div>
                    <div class="modal-footer">
                        <button class="modal-close bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600">é–‰ã˜ã‚‹</button>
                    </div>
                </div>`;
            modalContainer.appendChild(modalEl);
            
            // Trigger fade-in animation
            setTimeout(() => modalEl.classList.add('visible'), 10);

            const close = () => {
                modalEl.classList.remove('visible');
                setTimeout(() => modalEl.remove(), 300);
            };
            
            modalEl.querySelector('.modal-close').addEventListener('click', close);
            modalEl.addEventListener('click', (e) => { if (e.target === modalEl) close(); });
            return modalEl;
        }

        function updateModalContent(content, modalEl) {
            const target = modalEl ? modalEl.querySelector('.modal-body') : modalContainer.querySelector('.modal-overlay:last-child .modal-body');
            if(target) target.innerHTML = content;
        }
        
        // --- Utility Functions ---
        function formatTextToHtml(text) {
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/### (.*$)/gm, '<h4>$1</h4>')
                .replace(/## (.*$)/gm, '<h3>$1</h3>')
                .replace(/# (.*$)/gm, '<h2>$1</h2>')
                .replace(/^\* (.*$)/gm, '<li>$1</li>');
            html = html.replace(/<li>/g, '<ul><li>').replace(/<\/li>/g, '</li></ul>');
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            return html.replace(/\n/g, '<br>').replace(/<br><br>/g, '<br>');
        }
        function setApiButtonsState(inProgress) {
            isApiCallInProgress = inProgress;
            document.querySelectorAll('#toolbox button').forEach(button => button.disabled = inProgress);
        }
        function getMagnitudeColor(mag) { if (mag >= 7) return '#b30000'; if (mag >= 6) return '#d73027'; if (mag >= 5) return '#fc8d59'; if (mag >= 4) return '#fee08b'; return '#91cf60'; }
        function getJmaShindoColor(shindo) { const map = { '7':'#580b27', '6å¼·':'#b30000', '6å¼±':'#d73027', '5å¼·':'#fc8d59', '5å¼±':'#fee08b', '4':'#ffffbf', '3':'#d9ef8b', '2':'#91cf60', '1':'#1a9850', '0':'#cccccc' }; return map[shindo] || '#cccccc'; }
        function convertMmiToRoman(mmi) { if (mmi == null || mmi < 1) return 'æƒ…å ±ãªã—'; const map = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}; const roundedMmi = Math.round(mmi); if (roundedMmi >= 10) return 'X+'; return map[roundedMmi] || 'æƒ…å ±ãªã—'; }
        function convertMmiToJmaShindo(mmi) { if (mmi == null || mmi < 0) return 'æƒ…å ±ãªã—'; if (mmi < 0.5) return '0'; if (mmi < 1.5) return '1'; if (mmi < 2.5) return '2'; if (mmi < 3.5) return '3'; if (mmi < 4.5) return '4'; if (mmi < 5.0) return '5å¼±'; if (mmi < 5.5) return '5å¼·'; if (mmi < 6.0) return '6å¼±'; if (mmi < 6.5) return '6å¼·'; return '7'; }
        function convertScale(scale) { const scaleMap = { 10:'1', 20:'2', 30:'3', 40:'4', 45:'5å¼±', 50:'5å¼·', 55:'6å¼±', 60:'6å¼·', 70:'7' }; return scaleMap[scale] ?? 'ä¸æ˜'; }
        function isDarkColor(hexcolor) { if (!hexcolor.startsWith('#')) return false; const r = parseInt(hexcolor.substr(1, 2), 16), g = parseInt(hexcolor.substr(3, 2), 16), b = parseInt(hexcolor.substr(5, 2), 16); return ((r * 299) + (g * 587) + (b * 114)) / 1000 < 128; }

        // --- Location Picker Logic ---
        function enterPinMode() {
            L.DomUtil.addClass(map.getContainer(), 'map-pin-mode');
            map.once('click', onMapClick);
        }
        async function onMapClick(e) {
            const { lat, lng } = e.latlng;
            userCoords = { lat, lng };
            L.DomUtil.removeClass(map.getContainer(), 'map-pin-mode');
            const locationInput = document.getElementById('location-input');
            locationInput.value = 'åº§æ¨™ã‹ã‚‰ä½æ‰€ã‚’æ¤œç´¢ä¸­...';
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=ja`);
                if(!response.ok) throw new Error("Network response was not ok.");
                const data = await response.json();
                if (data && data.address) {
                    const address = data.address;
                    const displayAddress = `${address.country || ''} ${address.state || ''} ${address.city || address.town || address.village || ''}`.trim();
                    locationInput.value = displayAddress || 'ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                } else {
                    locationInput.value = 'ä½æ‰€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ';
                }
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                locationInput.value = 'ä½æ‰€ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ';
            }
        }
        function getCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => onMapClick({ latlng: { lat: position.coords.latitude, lng: position.coords.longitude } }),
                    (error) => { alert(`GPSæƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`); }
                );
            } else {
                alert("ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯GPSæ©Ÿèƒ½ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
            }
        }
        
        function initializeDroneMap(droneMapInstance, start, end, durationMinutes, missionLog) {
            const startCoords = L.latLng(start[0], start[1]);
            const endCoords = L.latLng(end[0], end[1]);

            const destinationIcon = L.divIcon({className: 'text-4xl', html: 'ğŸ '});
            const droneBaseIcon = L.divIcon({className: 'text-4xl', html: 'ğŸ“¡'});
            const droneIcon = L.divIcon({className: 'text-4xl drone-icon', html: 'ğŸš'});

            L.marker(endCoords, {icon: destinationIcon}).addTo(droneMapInstance).bindTooltip("ç›®çš„åœ°");
            L.marker(startCoords, {icon: droneBaseIcon}).addTo(droneMapInstance).bindTooltip("ãƒ‰ãƒ­ãƒ¼ãƒ³åŸºåœ°");
            
            const route = L.polyline([startCoords, endCoords], {color: 'blue', dashArray: '5, 10'}).addTo(droneMapInstance);
            droneMapInstance.fitBounds(route.getBounds().pad(0.2));

            const movingDrone = L.marker(startCoords, {icon: droneIcon}).addTo(droneMapInstance);
            animateDrone(movingDrone, route, durationMinutes * 60 * 1000, missionLog);
        }
        
        function animateDrone(marker, route, duration, missionLog) {
            if (droneAnimationId) cancelAnimationFrame(droneAnimationId);
            let start = null;
            const latlngs = route.getLatLngs();
            const missionLogEl = document.getElementById('drone-response-container')?.querySelector('#mission-log');
            const speedEl = document.getElementById('drone-response-container')?.querySelector('#drone-speed');
            const altitudeEl = document.getElementById('drone-response-container')?.querySelector('#drone-altitude');
            const batteryEl = document.getElementById('drone-response-container')?.querySelector('#drone-battery');
            const etaEl = document.getElementById('drone-response-container')?.querySelector('#drone-eta');

            let currentLogIndex = 0;

            function animationStep(timestamp) {
                if (!start) start = timestamp;
                const progress = timestamp - start;
                const ratio = Math.min(progress / duration, 1);

                if (missionLogEl && (currentLogIndex < missionLog.length) && (missionLog[currentLogIndex].time * 60 * 1000) <= progress) {
                    const logEntry = document.createElement('p');
                    logEntry.textContent = `[${new Date(Date.now() + progress).toLocaleTimeString()}] ${missionLog[currentLogIndex].event}`;
                    missionLogEl.appendChild(logEntry);
                    missionLogEl.scrollTop = missionLogEl.scrollHeight;
                    currentLogIndex++;
                }

                if(speedEl) speedEl.textContent = `${(50 + Math.random() * 10).toFixed(1)} km/h`;
                if(altitudeEl) altitudeEl.textContent = `${(100 + Math.random() * 20).toFixed(1)} m`;
                if(batteryEl) batteryEl.textContent = `${(100 - ratio * 70).toFixed(1)} %`;
                const remainingMinutes = (duration - progress) / 1000 / 60;
                if(etaEl) etaEl.textContent = `${Math.max(0, remainingMinutes).toFixed(1)} åˆ†`;

                if (ratio < 1) {
                    const newLatLng = L.latLng(
                        latlngs[0].lat + ratio * (latlngs[1].lat - latlngs[0].lat),
                        latlngs[0].lng + ratio * (latlngs[1].lng - latlngs[0].lng)
                    );
                    marker.setLatLng(newLatLng);
                    droneAnimationId = requestAnimationFrame(animationStep);
                } else {
                    marker.setLatLng(latlngs[1]);
                    marker.setIcon(L.divIcon({className: 'text-4xl', html: 'âœ…'}));
                    if(etaEl) etaEl.textContent = 'åˆ°ç€æ¸ˆã¿';
                }
            }
            droneAnimationId = requestAnimationFrame(animationStep);
        }

        // --- Event Listeners ---
        document.body.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if(!target) return;
            
            const targetId = target.id;
            switch(targetId) {
                case 'prepare-button': generatePreparednessTips(); break;
                case 'safety-report-button': 
                    const locationInput = document.getElementById('location-input');
                    const householdType = document.getElementById('household-type');
                    generateSafetyReport(locationInput.value, householdType.value); 
                    break;
                case 'map-select-button': enterPinMode(); break;
                case 'gps-button': getCurrentLocation(); break;
                case 'drone-request-button': handleDroneRequest(); break;
                case 'power-outage-button': generatePowerOutageReport(); break;
                case 'drone-future-button': generateDroneFutureReport(); break;
                case 'transit-advice-button': generateTransitAdvice(); break;
                case 'add-map-note-button':
                    showModal('æƒ…å ±å…±æœ‰', `
                        <p>åœ°å›³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æƒ…å ±ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</p>
                        <div class="space-y-2">
                            <div>
                                <label for="note-type">æƒ…å ±ã®ç¨®é¡:</label>
                                <select id="note-type" class="border rounded p-1">
                                    <option value="danger">å±é™ºç®‡æ‰€ âš ï¸</option>
                                    <option value="support">æ”¯æ´æ‹ ç‚¹ ğŸ¤</option>
                                    <option value="supply">ç‰©è³‡æƒ…å ± ğŸ“¦</option>
                                </select>
                            </div>
                            <div>
                                <label for="note-comment">ã‚³ãƒ¡ãƒ³ãƒˆ:</label>
                                <input type="text" id="note-comment" class="border rounded p-1 w-full" placeholder="ä¾‹ï¼šã“ã®å…ˆã®æ©‹ãŒé€šè¡Œæ­¢ã‚ã§ã™">
                            </div>
                            <button id="submit-note" class="bg-blue-500 text-white p-2 rounded">è¿½åŠ </button>
                        </div>
                    `);
                    document.getElementById('submit-note').onclick = () => {
                         map.once('click', (e) => {
                            const type = document.getElementById('note-type').value;
                            const comment = document.getElementById('note-comment').value;
                            const icons = { danger: 'âš ï¸', support: 'ğŸ¤', supply: 'ğŸ“¦' };
                            L.marker(e.latlng, { icon: L.divIcon({className: 'text-2xl', html: icons[type]}) })
                                .addTo(notesLayer)
                                .bindPopup(`<strong>${type}</strong><br>${comment}`);
                        });
                        alert("åœ°å›³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦æƒ…å ±ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚");
                        modalContainer.innerHTML = '';
                    };
                    break;
            }
        });
        
        document.getElementById('mode-toggle-button').addEventListener('click', () => {
            const isWorld = currentMode === 'japan';
            switchMode(isWorld ? 'world' : 'japan');
        });

        // --- Initial Load ---
        switchMode('japan'); // Start with Japan mode as requested
        fetchTectonicPlates();
    });
    </script>
</body>
</html>
