<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>統合版 地震情報ビューア (総合防災AI版) - v6.6</title>
    
    <!-- Leaflet.js CSS and Script -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">

    <style>
        /* Custom styles for a polished look */
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; overflow: hidden; }
        #map { height: 100vh; width: 100vw; }
        .leaflet-popup-content { font-size: 14px; line-height: 1.6; }
        .plate-tooltip { background-color: rgba(0, 0, 0, 0.7) !important; border: none !important; box-shadow: none !important; color: white !important; font-weight: bold; font-size: 14px; padding: 4px 8px !important; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; margin: 1rem auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Modal styles with smooth animation */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-container {
            background-color: white; padding: 0; border-radius: 0.5rem;
            width: 90%; max-width: 500px; max-height: 85vh;
            display: flex; flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s ease;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }
        .modal-overlay.visible .modal-container { transform: scale(1); }
        .modal-header { flex-shrink: 0; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; }
        .modal-body { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        .modal-footer { flex-shrink: 0; text-align: right; padding: 1rem 1.5rem; border-top: 1px solid #e5e7eb; }
        .modal-container h2 { font-size: 1.5rem; font-weight: bold; }
        .modal-container h3 { font-size: 1.2rem; font-weight: bold; margin-top: 1.5rem; margin-bottom: 0.5rem; }
        .modal-container p, .modal-container ul { font-size: 0.9rem; line-height: 1.8; margin-bottom: 1rem; }
        .modal-container li { margin-left: 1.5rem; list-style-type: disc; }
        
        /* Floating Toolbox */
        #toolbox {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            border-radius: 999px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            gap: 8px;
        }
        .tool-button {
            background-color: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .tool-button:hover { background-color: #e5e7eb; transform: translateY(-2px); }
        .tool-button:disabled { cursor: not-allowed; background-color: #e5e7eb; opacity: 0.5; }
        .tool-button svg { width: 24px; height: 24px; }
        
        .map-pin-mode { cursor: crosshair !important; }
        #drone-dashboard {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 500;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            width: 280px;
            border: 1px solid #ccc;
        }
        #drone-dashboard h4 { font-weight: bold; margin-bottom: 8px; }
        #mission-log {
            font-family: monospace;
            font-size: 11px;
            background-color: #2d3748;
            color: #a0aec0;
            padding: 8px;
            border-radius: 4px;
            height: 100px;
            overflow-y: auto;
            margin-top: 8px;
        }
        .drone-icon { transition: all 1s linear; }
        .list-item-hover:hover { background-color: #f0f9ff; }
        .analysis-disclaimer { background-color: #fffbeb; border-left: 4px solid #fbbf24; padding: 1rem; margin-bottom: 1rem; }

        /* Custom Leaflet controls for location */
        .leaflet-bar a.leaflet-control-location,
        .leaflet-bar a.leaflet-control-location:hover,
        .leaflet-bar a.leaflet-control-pindrop,
        .leaflet-bar a.leaflet-control-pindrop:hover {
            background-size: 18px 18px;
            background-position: center;
            background-repeat: no-repeat;
        }
        .leaflet-bar a.leaflet-control-location,
        .leaflet-bar a.leaflet-control-location:hover {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23333"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/></svg>');
        }
        .leaflet-bar a.leaflet-control-pindrop,
        .leaflet-bar a.leaflet-control-pindrop:hover {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23333"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>');
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div id="map-container" class="w-screen h-screen relative">
        <div id="map"></div>
        <!-- Drone Dashboard - Always present, visibility toggled by JS -->
        <div id="drone-dashboard" class="hidden">
            <h4 class="lg:text-lg">ドローンミッション状況</h4>
            <div class="text-sm space-y-1">
                <p>速度: <span id="drone-speed">0.0</span> km/h</p>
                <p>高度: <span id="drone-altitude">0.0</span> m</p>
                <p>バッテリー: <span id="drone-battery">100.0</span> %</p>
                <p>風速: <span id="drone-wind-speed">0.0</span> m/s</p>
                <p>障害物検知: <span id="drone-obstacle-detection">なし</span></p>
                <p>ETA: <span id="drone-eta">計算中...</span></p>
            </div>
            <h5 class="md:text-md font-bold mt-4">ミッションログ</h5>
            <div id="mission-log" class="text-xs"></div>
            <button id="cancel-drone-mission" class="w-full mt-4 bg-red-500 text-white font-bold py-2 px-4 rounded-md hover:bg-red-600">ミッションキャンセル</button>
        </div>
    </div>
    
    <div id="toolbox">
        <button id="mode-toggle-button" class="tool-button" title="モード切替"></button>
        <button id="filter-button" class="tool-button" title="フィルター">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3c2.755 0 5.455.232 8.083.678.533.09.917.556.917 1.096v1.044a2.25 2.25 0 01-.659 1.591l-5.432 5.432a2.25 2.25 0 00-.659 1.591v2.927a2.25 2.25 0 01-1.244 2.013L9.75 21v-6.572a2.25 2.25 0 00-.659-1.591L3.659 7.409A2.25 2.25 0 013 5.818V4.774c0-.54.384-1.006.917-1.096A48.32 48.32 0 0112 3z" /></svg>
        </button>
        <button id="ai-tools-button" class="tool-button" title="AI防災ツール">
             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM18 15.75l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 18l-1.035.259a3.375 3.375 0 00-2.456 2.456L18 21.75l-.259-1.035a3.375 3.375 0 00-2.456-2.456L14.25 18l1.035-.259a3.375 3.375 0 002.456-2.456L18 15.75z" /></svg>
        </button>
        <button id="info-share-button" class="tool-button" title="情報共有">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
        </button>
        <button id="drone-request-button" class="tool-button" title="ドローン支援要請">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
        </button>
        <button id="show-drone-narrative-button" class="tool-button hidden" title="ドローンミッション情報を表示">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M18 10.5H6a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25h12a2.25 2.25 0 002.25-2.25v-6.75A2.25 2.25 0 0018 10.5z" />
            </svg>
        </button>
    </div>

    <!-- Modals -->
    <div id="modal-container"></div>
    <div id="drone-narrative-modal" class="modal-overlay hidden">
        <div class="modal-container">
            <div class="modal-header">
                <h2 class="text-xl font-bold">ドローンミッション情報</h2>
            </div>
            <div class="modal-body"></div>
            <div class="modal-footer">
                <button class="modal-close bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600">閉じる</button>
            </div>
        </div>
    </div>


    <!-- Main application logic -->
    <script type="module">
    document.addEventListener('DOMContentLoaded', () => {
        // --- Constants and Global Variables ---
        const USGS_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson';
        const USGS_DISASTER_API_URL = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson';
        const P2P_API_BASE_URL = 'https://api.p2pquake.net/v2/history?codes=551&limit=';
        const TECTONIC_PLATES_URL = 'https://raw.githubusercontent.com/fraxen/tectonicplates/master/GeoJSON/PB2002_plates.json';
        
        let currentMode = 'japan';
        let allEarthquakeData = [];
        let filteredEarthquakeData = [];
        let quakeMarkers = {};
        let isApiCallInProgress = false;
        let userCoords = null;
        let userAddress = null; // Centralized address storage
        let droneAnimationId = null;
        let locationMarker = null; // To keep track of the location marker
        let droneMarkers = []; // To keep track of drone related markers and layers

        // Global variable to store last drone mission data for replay
        let lastDroneMission = null; 
        let lastDroneNarrative = null; // Stores the narrative content for re-opening
        let currentDroneState = { // For smoother real-time data
            speed: 0,
            altitude: 0,
            battery: 100,
            windSpeed: 0,
            obstacleDetected: false,
            targetSpeed: 50, // Target speed in km/h
            targetAltitude: 100, // Target altitude in meters
            targetWindSpeed: 5 // Target wind speed in m/s
        };

        // --- DOM Elements ---
        const modalContainer = document.getElementById('modal-container');
        const droneDashboard = document.getElementById('drone-dashboard');
        const showDroneNarrativeButton = document.getElementById('show-drone-narrative-button');
        const droneNarrativeModalEl = document.getElementById('drone-narrative-modal');


        // --- Leaflet Map Initialization ---
        const map = L.map('map');
        const quakeLayer = L.layerGroup().addTo(map);
        const platesLayer = L.layerGroup();
        const tsunamiLayer = L.layerGroup().addTo(map);
        const notesLayer = L.layerGroup().addTo(map);
        const droneLayer = L.layerGroup().addTo(map); // Dedicated layer for drone elements
        const gsiTile = L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
            attribution: "<a href='https://maps.gsi.go.jp/development/ichiran.html' target='_blank'>地理院タイル</a>"
        }).addTo(map);
        const baseMaps = { "地理院タイル": gsiTile };
        const overlayMaps = { "地震情報": quakeLayer, "プレート": platesLayer, "津波浸水予測": tsunamiLayer, "共有情報": notesLayer, "ドローン": droneLayer };
        L.control.layers(baseMaps, overlayMaps).addTo(map);

        // --- Custom Map Controls ---
        // GPS Location Control
        L.Control.Location = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                const button = L.DomUtil.create('a', 'leaflet-control-location', container);
                button.href = '#';
                button.title = '現在地に移動';
                button.role = 'button';

                L.DomEvent.on(button, 'click', L.DomEvent.stopPropagation)
                            .on(button, 'click', L.DomEvent.preventDefault)
                            .on(button, 'click', () => map.locate({setView: true, maxZoom: 16}));

                return container;
            },
            onRemove: function(map) { /* Nothing to do here */ }
        });
        L.control.location = (opts) => new L.Control.Location(opts);
        L.control.location({ position: 'topleft' }).addTo(map);

        // Pin Drop Control
        L.Control.PinDrop = L.Control.extend({
            onAdd: function(map) {
                const container = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
                const button = L.DomUtil.create('a', 'leaflet-control-pindrop', container);
                button.href = '#';
                button.title = '地図をクリックして場所を指定';
                button.role = 'button';

                L.DomEvent.on(button, 'click', L.DomEvent.stopPropagation)
                            .on(button, 'click', L.DomEvent.preventDefault)
                            .on(button, 'click', enterPinDropMode);
                return container;
            },
            onRemove: function(map) { /* Nothing to do here */ }
        });
        L.control.pindrop = (opts) => new L.Control.PinDrop(opts);
        L.control.pindrop({ position: 'topleft' }).addTo(map);


        // --- Map Event Listeners for Location ---
        map.on('locationfound', async function(e) {
            if (locationMarker) {
                map.removeLayer(locationMarker);
            }
            const pinIcon = L.divIcon({className: 'text-4xl', html: '🔵'});
            locationMarker = L.marker(e.latlng, {icon: pinIcon, draggable: true}).addTo(map);
            
            locationMarker.on('dragend', function(event) {
                updatePinAddress(event.target);
            });

            await updatePinAddress(locationMarker, `あなたの現在地 (誤差 ${Math.round(e.accuracy)} m)`);
            locationMarker.openPopup();
        });
        map.on('locationerror', function(e) {
            showModal('GPSエラー', `<p>GPS情報の取得に失敗しました: ${e.message}</p>`);
        });
        
        // --- Gemini API Call ---
        async function callGeminiApi(prompt) {
            setApiButtonsState(true);
            const apiKey = ""; // Handled by Canvas
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`APIリクエストに失敗しました: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0].content.parts[0].text) return result.candidates[0].content.parts[0].text;
                else throw new Error('無効なAPIレスポンスです。');
            } catch (error) {
                console.error("Gemini API Error:", error);
                return `エラーが発生しました: ${error.message}`;
            } finally { setApiButtonsState(false); }
        }

        // --- AI Feature Functions ---
        async function generateAnalysis() {
            showModal('✨ AIによる分析と見通し', '<div class="spinner"></div>');
            if (filteredEarthquakeData.length === 0) { 
                updateModalContent('<p>分析対象の地震データがありません。</p>'); return;
            }
            const largestQuake = filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]);
            const dataSummary = `最大地震: M${largestQuake.earthquake.hypocenter.magnitude.toFixed(1)} at ${largestQuake.displayPlace}. 地震件数: ${filteredEarthquakeData.length}.`;
            const prompt = `あなたは冷静で信頼できる地震学者です。以下の地震データ概要を基に、一般市民向けの簡潔な分析レポートを作成してください。レポートには以下の要素を含めてください。1. **活動の概要**: 最大地震や活発な地域について言及。2. **地質学的背景**: プレートの動きなど、地震の発生メカニズムを簡単に解説。3. **今後の見通し**: 特定の予測はせず、一般的な注意喚起（例：余震の可能性）に留める。4. **防災への呼びかけ**: ポジティブかつ具体的に、日頃の備えの重要性を訴える。全体をMarkdown形式で、親しみやすく、かつ権威を損なわないトーンで記述してください。データ概要: ${dataSummary}`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateSafetyReport(location, household) {
            if (!location) { 
                showModal('エラー', '<p>場所を指定してください。</p>');
                return;
            }
            showModal('✨ MY防災レポート', '<div class="spinner"></div>');
            const dataSummary = `現在の地震活動の最大規模はM${filteredEarthquakeData.reduce((max, q) => Math.max(max, q.earthquake.hypocenter.magnitude), 0).toFixed(1)}です。`;
            const prompt = `あなたは地域の防災アドバイザーです。ユーザーは「${location}」に住んでおり、世帯構成は「${household}」です。現在の地震活動（${dataSummary}）を踏まえ、その地域と世帯構成に特化したパーソナルな防災レポートを作成してください。レポートには以下の要素を含めてください。1. **地域特性の考慮**: ${location}の地理的特徴（例：沿岸部、都市部、山間部など）を考慮した具体的なリスクについて言及。2. **世帯構成に合わせた備え**: 「${household}」に特に重要な、具体的なアクションを提案。3. **備蓄品リスト**: 世帯構成に合わせた非常用持ち出し袋の中身をリスト形式で提案。4. **物資確保のアドバイス**: 災害時に水、食料、バッテリーなどの物資を確保するための具体的なアイデアを提案してください。5. **心のケア**: 不安を煽らず、備えることの重要性をポジティブに伝える。全体をMarkdown形式で、親しみやすく、具体的で役立つ内容にしてください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePreparednessTips() {
            showModal('💡 事前の備え (AI防災アドバイザー)', '<div class="spinner"></div>');
            const prompt = `あなたは経験豊富な防災コンサルタントです。地震が発生する前に家庭でできる予防策や、防災計画のアイデアをいくつか提案してください。家具の固定方法、備蓄品の選び方、家族との連絡方法の確認など、読者がすぐに行動に移せるような具体的で実践的なアドバイスをMarkdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generatePowerOutageReport() {
            const locationInput = document.getElementById('location-input');
            if (!locationInput || !locationInput.value) {
                showModal('エラー', '<p>停電リスク分析には、まず「MY防災レポート」セクションで場所を指定してください。</p>');
                return;
            }
            showModal('💡 停電リスク分析 (AI)', '<div class="spinner"></div>');
            const largestQuake = filteredEarthquakeData.length > 0 ? filteredEarthquakeData.reduce((max, q) => q.earthquake.hypocenter.magnitude > max.earthquake.hypocenter.magnitude ? q : max, filteredEarthquakeData[0]) : null;
            const prompt = `あなたは電力インフラに詳しい防災専門家です。ユーザーは「${locationInput.value}」にいます。現在、最大M${largestQuake ? largestQuake.earthquake.hypocenter.magnitude.toFixed(1) : '不明'}の地震が観測されています。この状況を踏まえ、以下の点についてアドバイスをください。
            1. **停電の可能性**: この規模の地震で、${locationInput.value}で停電が発生する一般的な可能性は？
            2. **復旧の見通し**: もし停電した場合、復旧にはどのくらいの時間がかかる可能性があるか？
            3. **今すぐできる対策**: 停電に備えて、今すぐできることは何か？(例: スマートフォンの充電、懐中電灯の準備など)
            専門的かつ分かりやすい言葉で、Markdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }
        
        async function generateDroneFutureReport() {
            showModal('🤖 AIと語るドローンの未来', '<div class="spinner"></div>');
            const prompt = `あなたはテクノロジーと社会の未来に詳しいアナリストです。「災害対策におけるドローンの重要性と今後の展望」というテーマで、一般向けの解説記事を執筆してください。以下の要素を必ず含めてください。
            1. **現在の活用事例**: 物資輸送、情報収集、被災者捜索など。
            2. **未来の可能性**: 1対n運航（群制御）、AIによる自律判断、救助活動への直接参加など、さらに進んだ活用方法。
            3. **解決すべき課題**: 法整備、機体性能の向上（バッテリー、積載量）、プライバシー保護、社会的な受容性など。
            読者が未来に希望を持てるような、前向きなトーンでMarkdown形式で記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function generateTransitAdvice() {
            showModal('🚗 交通機関向けAIアドバイス', '<div class="spinner"></div>');
            const prompt = `あなたは災害危機管理の専門家です。地震発生時に、様々な交通機関を利用している人々（運転手や乗客）に向けて、それぞれの状況に応じた具体的で安全な行動指針をアドバイスしてください。以下の項目を必ず含めてください。
            - **自動車を運転中の場合**
            - **バスやタクシーに乗車中の場合**
            - **鉄道（電車・新幹線）に乗車中の場合**
            - **バイクや自転車に乗っている場合**
            各項目で、「揺れている最中の行動」と「揺れが収まった後の行動」を明確に分けて説明してください。Markdown形式で、簡潔かつ分かりやすく記述してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        async function getHistoricalContext(quake) {
            showModal('✨ AIによる地域の地震履歴分析', '<div class="spinner"></div>');
            const prompt = `あなたは地震の歴史に詳しい専門家です。マグニチュード${quake.earthquake.hypocenter.magnitude.toFixed(1)}の地震が「${quake.displayPlace}」で発生しました。この地域における過去の特筆すべき地震活動や、プレートテクトニクスの観点からの地質学的な背景について、一般の人にも分かりやすく簡潔に解説してください。この地域は地震が多いことで知られていますか？もしあなたの知識ベースに著名な過去の地震があれば、それに言及してください。`;
            const resultText = await callGeminiApi(prompt);
            updateModalContent(formatTextToHtml(resultText));
        }

        // --- Core Feature Functions ---
        async function handleDroneRequest() {
            const modalId = `modal-drone-request-${Date.now()}`;
            const modalContent = `
                <div class="space-y-4">
                    <div>
                        <p class="text-sm mb-2">支援物資を受け取りたい場所を指定してください。</p>
                        <div class="space-y-2">
                            <input type="text" id="drone-location-input" placeholder="場所を入力 or 地図で指定" class="w-full p-2 border rounded-md">
                            <div class="flex gap-2">
                                <button id="drone-map-select-button" class="flex-1 bg-gray-200 py-2 px-4 rounded-md hover:bg-gray-300 text-sm">地図から選択</button>
                                <button id="drone-gps-button" class="flex-1 bg-gray-200 py-2 px-4 rounded-md hover:bg-gray-300 text-sm">現在地を取得</button>
                            </div>
                        </div>
                    </div>
                    <div>
                        <p>必要な物資を選択してください（複数選択可）：</p>
                        <div class="space-y-2 my-4">
                            <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="医薬品" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">医薬品 (応急手当セットなど)</span></label>
                            <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="食料・水" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">食料・水 (最低1日分)</span></label>
                            <label class="flex items-center"><input type="checkbox" name="drone-supplies" value="バッテリー" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"> <span class="ml-2">バッテリー (モバイル用)</span></label>
                        </div>
                    </div>
                    <div class="text-right">
                        <button id="submit-drone-request" class="bg-sky-600 text-white font-bold py-2 px-4 rounded-md hover:bg-sky-700">AIによるシミュレーションを開始</button>
                    </div>
                </div>
            `;
            const modalEl = showModal('🚁 ドローン支援要請 (シミュレーション)', modalContent, modalId);
            
            const locationInput = modalEl.querySelector('#drone-location-input');
            if (userAddress) {
                locationInput.value = userAddress;
            }

            modalEl.querySelector('#drone-map-select-button').addEventListener('click', () => enterPinMode('drone-location-input'));
            modalEl.querySelector('#drone-gps-button').addEventListener('click', () => getCurrentLocation('drone-location-input'));

            modalEl.querySelector('#submit-drone-request').addEventListener('click', async () => {
                const selectedSupplies = Array.from(modalEl.querySelectorAll('input[name="drone-supplies"]:checked')).map(cb => cb.value);
                
                if (!locationInput.value) {
                    updateModalContent('<p class="text-red-500">場所を指定してください。</p>', modalEl); return;
                }
                if (selectedSupplies.length === 0) {
                    updateModalContent('<p class="text-red-500">少なくとも1つの物資を選択してください。</p>', modalEl); return;
                }

                // Close the input modal
                modalEl.querySelector('.modal-close').click();

                // Show a temporary loading message or notification
                showModal('ドローンミッション開始', '<div class="spinner"></div><p class="text-center mt-4">ドローンミッションを準備中です...</p>', 'drone-loading-modal');

                const prompt = `あなたは災害対応ドローンの運用AIです。ユーザーから以下の内容で支援要請がありました。応答を\`\`\`json ... \`\`\` のようにMarkdownのコードブロック形式で生成してください。他のテキストは不要です。
                - **要請場所**: ${locationInput.value}
                - **要請場所の座標**: ${userCoords ? `緯度${userCoords.lat}, 経度${userCoords.lng}`: '不明'}
                - **要請物資**: ${selectedSupplies.join(', ')}
                - **現在の状況**: 大規模な地震が発生し、交通網に影響が出ている可能性がある。

                応答JSONの仕様:
                {
                  "departurePointName": "（${locationInput.value} 内の具体的な出発拠点名。市役所、大きな公園など）",
                  "departurePointLat": （出発地点の緯度）,
                  "departurePointLng": （出発地点の経度）,
                  "estimatedFlightMinutes": （現実的な飛行時間（分））,
                  "missionLog": [
                        {"time": 0, "event": "要請を受理しました。ドローンを発進準備中です。"},
                        {"time": 1, "event": "ドローンが拠点（${locationInput.value}防災センター）から離陸しました。"},
                        {"time": 5, "event": "高度100m、速度50km/hで安定飛行中。"},
                        {"time": 8, "event": "他の緊急車両との重複を避けるため、一時的にルートを調整します。"},
                        {"time": 12, "event": "目的地まであとわずかです。安全な場所で待機してください。"}
                  ],
                  "narrative": "（ユーザーへの応答メッセージ。要請受理、発進、到着予定、飛行経路、受け取り時の注意、免責事項を含むMarkdown形式のテキスト）"
                }`;
                const resultText = await callGeminiApi(prompt);
                
                // Close loading modal
                document.getElementById('drone-loading-modal')?.remove();

                try {
                    const jsonMatch = resultText.match(/```json\n([\s\S]*?)\n```/);
                    if (!jsonMatch || !jsonMatch[1]) throw new Error("AIの応答にJSONデータが含まれていません。");
                    const jsonString = jsonMatch[1];
                    const resultJson = JSON.parse(jsonString);
                    
                    // Store narrative for re-opening
                    lastDroneNarrative = formatTextToHtml(resultJson.narrative);
                    showDroneNarrativeButton.classList.remove('hidden'); // Show the button


                    // Show narrative in the dedicated modal
                    showDroneNarrativeModal();

                    if(userCoords) {
                        const startPoint = [resultJson.departurePointLat, resultJson.departurePointLng];
                        const endPoint = [userCoords.lat, userCoords.lng];
                        // Store mission data for replay (for static display)
                        lastDroneMission = {
                            start: startPoint,
                            end: endPoint,
                            durationMinutes: resultJson.estimatedFlightMinutes,
                            missionLog: resultJson.missionLog
                        };
                        // Initialize drone animation on the main map
                        initializeDroneMap(map, startPoint, endPoint, resultJson.estimatedFlightMinutes, resultJson.missionLog);
                    }
                } catch(e) {
                    console.error("Failed to parse drone response JSON", e);
                    showModal('エラー', `<p class="text-red-500">AIからの応答を解析できませんでした。通常のテキストで表示します。</p>${formatTextToHtml(resultText)}`);
                }
            });
        }
        
        function handleTsunamiSimulation(quake) {
            if (!quake.earthquake.tsunami) {
                showModal('津波情報', '<p>この地震による津波の心配はありません。</p>');
                return;
            }
            if (!userCoords) {
                showModal('エラー', '<p>シミュレーションには、まず「MY防災レポート」セクションであなたの場所を指定してください。</p>');
                return;
            }

            tsunamiLayer.clearLayers();
            
            // Simulate inundation zone
            const center = [quake.earthquake.hypocenter.latitude, quake.earthquake.hypocenter.longitude];
            const radius = 10000 + quake.earthquake.hypocenter.magnitude * 2000; // Simplified radius
            const circle = L.circle(center, {
                color: 'blue', fillColor: '#3388ff', fillOpacity: 0.3, radius: radius
            }).addTo(tsunamiLayer);

            // Simulate evacuation route
            const userLatLng = L.latLng(userCoords.lat, userCoords.lng);
            const bearing = map.project(center).subtract(map.project(userLatLng)).angle();
            const evacuationPoint = L.latLng(
                userLatLng.lat + Math.sin(bearing) * 0.05, // Approx 5km away
                userLatLng.lng + Math.cos(bearing) * 0.05
            );
            
            const route = L.polyline([userLatLng, evacuationPoint], {color: 'green', dashArray: '5, 5'}).addTo(tsunamiLayer);
            const shelterIcon = L.divIcon({className: 'text-4xl', html: '🏫'});
            L.marker(evacuationPoint, {icon: shelterIcon}).addTo(tsunamiLayer).bindTooltip("高台避難場所 (シミュレーション)");

            map.fitBounds(L.featureGroup([circle, route]).getBounds().pad(0.2));
            
            showModal('津波・避難シミュレーション', '<div class="analysis-disclaimer"><strong>【重要】</strong>これはシミュレーションです。実際の浸水域や避難経路とは異なります。実際の避難は、必ず自治体の指示に従ってください。</div><p>地図上に青で想定浸水域、緑の破線で高台への避難ルート（シミュレーション）を表示しました。</p>');
        }

        function switchMode(newMode) {
            if (currentMode === newMode && allEarthquakeData.length > 0) return;
            currentMode = newMode;
            if (locationMarker) {
                map.removeLayer(locationMarker);
                locationMarker = null;
            }
            map.setView(newMode === 'world' ? [20, 0] : [36, 138], newMode === 'world' ? 2 : 5);
            updateModeToggleButton();
            setTimeout(() => map.invalidateSize(), 0);
            allEarthquakeData = [];
            filteredEarthquakeData = [];
            fetchData();
        }

        function fetchData() {
            if (currentMode === 'world') {
                fetchWorldData();
            } else {
                fetchJapanData();
            }
        }

        function applyFilters() {
            const magFilter = document.getElementById('mag-filter');
            const minMag = magFilter ? parseFloat(magFilter.value) : 0;
            
            filteredEarthquakeData = allEarthquakeData.filter(quake => quake.earthquake.hypocenter.magnitude >= minMag);
            
            if (currentMode === 'world') {
                const regionFilter = document.getElementById('region-filter');
                const selectedRegion = regionFilter ? regionFilter.value : 'all';
                if (selectedRegion !== 'all') {
                    filteredEarthquakeData = filteredEarthquakeData.filter(quake => quake.region === selectedRegion);
                }
            }
            renderEarthquakes(filteredEarthquakeData);
        }

        function renderEarthquakes(data) {
            const listElement = document.getElementById('earthquake-list');
            const quakeCount = document.getElementById('quake-count');
            
            quakeLayer.clearLayers();
            quakeMarkers = {};

            if (listElement) listElement.innerHTML = '';
            if (quakeCount) quakeCount.textContent = data.length;

            if (!data || data.length === 0) {
                if(listElement) listElement.innerHTML = '<li class="p-4 text-center text-gray-500">表示できる地震情報がありません。</li>'; 
                return;
            }
            
            data.sort((a, b) => b.time - a.time);
            
            data.forEach(quake => {
                const { hypocenter, tsunami, shindo } = quake.earthquake;
                const { latitude, longitude, magnitude, depth } = hypocenter;
                const { displayPlace, displayTime } = quake;
                const quakeId = quake.id;
                const radius = Math.pow(1.8, magnitude) * (currentMode === 'world' ? 3000 : 500);
                const fillColor = currentMode === 'world' ? getMagnitudeColor(magnitude) : getJmaShindoColor(shindo.value);
                const defaultStyle = { color: "#111", weight: 1, fillColor: fillColor, fillOpacity: 0.7, radius: radius };
                const highlightStyle = { color: "#000000", weight: 4 };
                const circle = L.circle([latitude, longitude], defaultStyle);
                const shindoLabel = shindo.type === 'JMA' ? '気象庁震度' : 'MMI震度';
                const shindoValue = shindo.value || '情報なし';
                
                const popupContent = document.createElement('div');
                popupContent.className = 'font-sans space-y-2';
                popupContent.innerHTML = `<strong class="text-base">発生時刻:</strong> ${displayTime}<br><strong class="text-base">震源地:</strong> ${displayPlace}<br><strong class="text-base">マグニチュード:</strong> ${magnitude.toFixed(1)}<br><strong class="text-base">深さ:</strong> ${depth.toFixed(1)} km<br><strong class="text-base">${shindoLabel}:</strong> ${shindoValue}<br><strong class="text-base">津波の可能性:</strong> ${tsunami ? 'あり' : 'なし'}`;
                
                const historyButton = document.createElement('button');
                historyButton.className = 'w-full mt-2 text-sm bg-purple-600 text-white font-bold py-1 px-2 rounded-md hover:bg-purple-700 transition-colors';
                historyButton.innerHTML = '✨ この地域の過去の活動をAI分析';
                historyButton.onclick = () => getHistoricalContext(quake);
                
                const tsunamiButton = document.createElement('button');
                tsunamiButton.className = 'w-full mt-1 text-sm bg-cyan-600 text-white font-bold py-1 px-2 rounded-md hover:bg-cyan-700 transition-colors';
                tsunamiButton.innerHTML = '🌊 津波・避難シミュレーション';
                tsunamiButton.onclick = () => handleTsunamiSimulation(quake);

                popupContent.appendChild(historyButton);
                popupContent.appendChild(tsunamiButton);
                circle.bindPopup(popupContent);

                quakeLayer.addLayer(circle);
                
                if (listElement) {
                    const listItem = document.createElement('li');
                    listItem.className = 'p-3 border rounded-lg shadow-sm list-item-hover transition-colors duration-200 cursor-pointer';
                    listItem.innerHTML = `<div class="font-semibold text-gray-800">${displayPlace} ${tsunami ? '🌊' : ''}</div><div class="text-sm text-gray-600">${displayTime}</div><div class="flex flex-wrap justify-between items-center mt-2 text-sm gap-x-4 gap-y-1"><span class="font-bold px-2 py-1 rounded-md" style="background-color:${fillColor}; color: ${isDarkColor(fillColor) ? 'white' : 'black'}">マグニチュード ${magnitude.toFixed(1)}</span><span>深さ: ${depth.toFixed(1)} km</span><span>${shindoLabel}: ${shindoValue}</span></div>`;
                    listItem.addEventListener('mouseover', () => { circle.setStyle(highlightStyle).bringToFront(); });
                    listItem.addEventListener('mouseout', () => { circle.setStyle(defaultStyle); });
                    listItem.addEventListener('click', () => { map.flyTo([latitude, longitude], 6); circle.openPopup(); });
                    listElement.appendChild(listItem);
                }
                quakeMarkers[quakeId] = { circle };
            });
        }
        
        async function fetchTectonicPlates() {
            const plateNameMap = { "African": "アフリカプレート", "Antarctic": "南極プレート", "Arabian": "アラビアプレート", "Australian": "オーストラリアプレート", "Caribbean": "カリブプレート", "Cocos": "ココスプレート", "Eurasian": "ユーラシアプレート", "Indian": "インドプレート", "Juan de Fuca": "ファンデフカプレート", "Nazca": "ナスカプレート", "North American": "北米プレート", "Okhotsk": "オホーツクプレート", "Pacific": "太平洋プレート", "Philippine Sea": "フィリピン海プレート", "Scotia": "スコシアプレート", "South American": "南米プレート" };
            try {
                const response = await fetch(TECTONIC_PLATES_URL);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const platesData = await response.json();
                L.geoJSON(platesData, { style: { color: "#ff7800", weight: 2, opacity: 0.65, fillColor: "#ff7800", fillOpacity: 0.1 }, onEachFeature: (feature, layer) => { if (feature.properties && feature.properties.PlateName) { const displayName = plateNameMap[feature.properties.PlateName] || feature.properties.PlateName; layer.bindTooltip(displayName, { permanent: false, direction: 'center', className: 'plate-tooltip' }); } } }).addTo(platesLayer);
            } catch (error) { console.error('Failed to fetch tectonic plates data:', error); }
        }

        async function fetchWorldData(isDisaster = false) {
            const url = isDisaster ? USGS_DISASTER_API_URL : USGS_API_URL;
            const countryNameMap = { "CA": "カリフォルニア", "California": "カリフォルニア", "Alaska": "アラスカ", "Hawaii": "ハワイ", "Indonesia": "インドネシア", "Japan": "日本", "Philippines": "フィリピン", "Fiji": "フィジー", "Chile": "チリ", "Mexico": "メキシコ", "New Zealand": "ニュージーランド", "Russia": "ロシア", "Papua New Guinea": "パプアニューギニア", "Tonga": "トンガ", "Vanuatu": "バヌアツ", "Solomon Islands": "ソロモン諸島", "Taiwan": "台湾", "China": "中国", "Turkey": "トルコ", "Greece": "ギリシャ", "Italy": "イタリア", "Iran": "イラン", "Peru": "ペルー", "Argentina": "アルゼンチン", "Colombia": "コロンビア", "Ecuador": "エクアドル", "Guatemala": "グアテマラ", "Costa Rica": "コスタリカ", "Nicaragua": "ニカラグア", "El Salvador": "エルサルバドル", "Honduras": "ホンジュラス", "Panama": "パナマ", "Puerto Rico": "プエルトリコ", "Dominican Republic": "ドミニカ共和国", "Iceland": "アイスランド", "Portugal": "ポルトガル", "Spain": "スペイン", "India": "インド", "Pakistan": "パキスタン", "Afghanistan": "アフガニスタン", "Kyrgyzstan": "キルギス", "Tajikistan": "タジキスタン", "Uzbekistan": "ウズベキスタン" };
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                const regions = new Set();
                allEarthquakeData = data.features.map(feature => {
                    const place = feature.properties.place; const latitude = feature.geometry.coordinates[1]; const longitude = feature.geometry.coordinates[0];
                    let region = place, japanesePlace = place, isJapan = false;
                    if (place && place.includes(',')) { const parts = place.split(','); region = parts[parts.length - 1].trim(); if (region === "Japan") isJapan = true; const translatedRegion = countryNameMap[region] || region; japanesePlace = `${translatedRegion} - ${parts.slice(0, -1).join(',')}`; } else if (place && place.toLowerCase().includes("japan")) { isJapan = true; region = "Japan"; japanesePlace = place; }
                    regions.add(region);
                    const isNearJapan = latitude >= 20 && latitude <= 46 && longitude >= 122 && longitude <= 154;
                    const displayTime = isNearJapan ? new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (日本時間)' : new Date(feature.properties.time).toLocaleString('ja-JP', { timeZone: 'UTC' }) + ' (協定世界時)';
                    return { id: feature.id, time: feature.properties.time, region: region, displayPlace: japanesePlace, isJapan: isJapan, displayTime: displayTime, earthquake: { hypocenter: { latitude: latitude, longitude: longitude, depth: feature.geometry.coordinates[2], magnitude: feature.properties.mag }, tsunami: feature.properties.tsunami, shindo: { type: isJapan ? 'JMA' : 'MMI', value: isJapan ? convertMmiToJmaShindo(feature.properties.mmi) : convertMmiToRoman(feature.properties.mmi) } } };
                });
                populateRegionFilter(regions); applyFilters();
            } catch (error) { console.error('Failed to fetch world data:', error); }
        }
        
        async function fetchJapanData(limit = 100) {
            try {
                const response = await fetch(P2P_API_BASE_URL + limit);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                allEarthquakeData = data.map(q => {
                    const { earthquake, id, time } = q;
                    return { id: id, time: new Date(time).getTime(), region: 'Japan', displayPlace: earthquake.hypocenter.name, isJapan: true, displayTime: new Date(time).toLocaleString('ja-JP', { timeZone: 'Asia/Tokyo' }) + ' (日本時間)', earthquake: { hypocenter: { latitude: parseFloat(earthquake.hypocenter.latitude), longitude: parseFloat(earthquake.hypocenter.longitude), depth: parseFloat(earthquake.hypocenter.depth), magnitude: parseFloat(earthquake.hypocenter.magnitude) }, tsunami: earthquake.tsunami?.text.includes('津波の心配はありません') === false, shindo: { type: 'JMA', value: convertScale(earthquake.maxScale) } } };
                });
                applyFilters();
            } catch(error) { console.error('Failed to fetch Japan data:', error); }
        }

        function populateRegionFilter(regions) {
            const regionFilter = document.getElementById('region-filter');
            if(!regionFilter) return;
            const currentVal = regionFilter.value;
            regionFilter.innerHTML = '<option value="all">すべての地域</option>';
            const sortedRegions = Array.from(regions).sort();
            sortedRegions.forEach(region => { const option = document.createElement('option'); option.value = region; option.textContent = region; regionFilter.appendChild(option); });
            regionFilter.value = currentVal;
        }
        
        // --- Modal and UI Logic ---
        function showModal(title, content, modalId = `modal-${Date.now()}`) {
            // For general modals, remove existing with same ID or create new
            const existingModal = document.getElementById(modalId);
            if(existingModal) existingModal.remove();

            const modalEl = document.createElement('div');
            modalEl.id = modalId;
            modalEl.className = 'modal-overlay';
            modalEl.innerHTML = `
                <div class="modal-container">
                    <div class="modal-header">
                        <h2 class="text-xl font-bold">${title}</h2>
                    </div>
                    <div class="modal-body">${content}</div>
                    <div class="modal-footer">
                        <button class="modal-close bg-gray-500 text-white font-bold py-2 px-4 rounded-md hover:bg-gray-600">閉じる</button>
                    </div>
                </div>`;
            modalContainer.appendChild(modalEl);
            
            setTimeout(() => modalEl.classList.add('visible'), 10);

            const close = () => {
                modalEl.classList.remove('visible');
                setTimeout(() => modalEl.remove(), 300);
            };
            
            modalEl.querySelector('.modal-close').addEventListener('click', close);
            modalEl.addEventListener('click', (e) => { if (e.target === modalEl) close(); });
            return modalEl;
        }

        function showDroneNarrativeModal() {
            if (!lastDroneNarrative) {
                showModal('情報なし', '<p>表示するドローンミッション情報がありません。まず新しいミッションを開始してください。</p>');
                return;
            }

            // ONLY display static path if NO animation is currently running
            // If an animation is running, the droneLayer already contains the animated drone and route.
            if (!droneAnimationId && lastDroneMission) { // Check if animation is NOT active AND static mission data exists
                displayStaticDronePath(lastDroneMission.start, lastDroneMission.end);
            } else if (!droneAnimationId && !lastDroneMission) {
                // No animation running, but no last mission data either. Clear layer just in case.
                droneLayer.clearLayers();
            }


            // Reuse the pre-existing drone-narrative-modal element
            const modalEl = droneNarrativeModalEl;
            modalEl.querySelector('.modal-body').innerHTML = lastDroneNarrative;
            
            // Show the modal
            modalEl.classList.add('visible');
            modalEl.classList.remove('hidden'); // Ensure it's not hidden by display:none

            // Attach close listener if not already attached (or re-attach for safety)
            const closeButton = modalEl.querySelector('.modal-close');
            const closeHandler = () => {
                modalEl.classList.remove('visible');
                // Use 'hidden' class to truly hide it, not remove from DOM
                setTimeout(() => modalEl.classList.add('hidden'), 300); 
                // If animation is NOT running, clear the static path when modal is closed
                if (!droneAnimationId) {
                    droneLayer.clearLayers();
                }
            };
            closeButton.onclick = null; // Clear previous listeners
            closeButton.addEventListener('click', closeHandler);
            modalEl.onclick = (e) => { // Close when clicking outside
                if (e.target === modalEl) closeHandler();
            };
        }


        function updateModalContent(content, modalEl) {
            const target = modalEl ? modalEl.querySelector('.modal-body') : modalContainer.querySelector('.modal-overlay:last-child .modal-body');
            if(target) target.innerHTML = content;
        }

        function showAiToolsModal() {
            const content = `
                <div class="space-y-4">
                    <div>
                        <h3 class="text-lg font-bold mb-2">全体状況の分析</h3>
                        <p class="text-sm mb-2 text-gray-600">現在の地震活動全体の傾向をAIが分析し、今後の見通しや注意点を報告します。</p>
                        <button id="analysis-button" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700">活動状況のAI分析を開始</button>
                    </div>
                    <div class="border-t pt-4">
                        <h3 class="text-lg font-bold mb-2">MY防災レポート</h3>
                        <p class="text-sm mb-2 text-gray-600">あなたの場所と世帯構成に合わせた、パーソナルな防災計画をAIが作成します。</p>
                        <div class="space-y-2">
                            <input type="text" id="location-input" placeholder="場所を入力 or 地図で指定" class="w-full p-2 border rounded-md">
                            <div class="flex gap-2">
                                <button id="map-select-button" class="flex-1 bg-gray-200 py-2 px-4 rounded-md hover:bg-gray-300 text-sm">地図から選択</button>
                                <button id="gps-button" class="flex-1 bg-gray-200 py-2 px-4 rounded-md hover:bg-gray-300 text-sm">現在地を取得</button>
                            </div>
                            <select id="household-type" class="w-full p-2 border rounded-md">
                                <option>一人暮らし</option>
                                <option>二人暮らし</option>
                                <option>子どもがいる家庭</option>
                                <option>高齢者がいる家庭</option>
                            </select>
                            <button id="safety-report-button" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-md hover:bg-green-700">MY防災レポートを作成</button>
                        </div>
                    </div>
                    <div class="border-t pt-4">
                        <h3 class="text-lg font-bold mb-2">その他のAI防災ツール</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                            <button id="prepare-button" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700">事前の備え</button>
                            <button id="power-outage-button" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700">停電リスク分析</button>
                            <button id="transit-advice-button" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700">交通機関アドバイス</button>
                            <button id="drone-future-button" class="bg-indigo-600 text-white font-bold py-2 px-4 rounded-md hover:bg-indigo-700">ドローンの未来</button>
                        </div>
                    </div>
                </div>
            `;
            const modalEl = showModal('🤖 AI防災ツール', content);
            const locationInput = modalEl.querySelector('#location-input');
            if (userAddress) {
                locationInput.value = userAddress;
            }
        }

        function showFilterModal() {
            const worldFilterDisplay = currentMode === 'world' ? 'block' : 'none';
            const content = `
                <div class="space-y-4">
                    <div>
                        <label for="mag-filter" class="block mb-2 font-bold">最小マグニチュード: <span id="mag-value">0</span></label>
                        <input type="range" id="mag-filter" min="0" max="9" step="0.5" value="${document.getElementById('mag-filter')?.value || 0}" class="w-full">
                    </div>
                    <div id="world-filter-container" style="display: ${worldFilterDisplay};">
                        <label for="region-filter" class="block mb-2 font-bold">地域</label>
                        <select id="region-filter" class="w-full p-2 border rounded-md">
                            ${document.getElementById('region-filter')?.innerHTML || '<option value="all">すべての地域</option>'}
                        </select>
                    </div>
                    <div class="text-right">
                        <button id="apply-filter-button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700">適用</button>
                    </div>
                </div>
            `;
            const modalEl = showModal('絞り込みフィルター', content);
            const magFilter = modalEl.querySelector('#mag-filter');
            const magValue = modalEl.querySelector('#mag-value');
            magValue.textContent = magFilter.value;
            magFilter.addEventListener('input', () => magValue.textContent = magFilter.value);
        }

        function showInfoShareModal() {
            const content = `
                <p class="mb-4">地図上に追加したい情報の種類を選択し、コメントを入力してください。</p>
                <div class="space-y-3">
                    <div>
                        <label for="note-type" class="block text-sm font-medium text-gray-700">情報の種類</label>
                        <select id="note-type" class="mt-1 block w-full p-2 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="danger">危険箇所 ⚠️</option>
                            <option value="support">支援拠点 🤝</option>
                            <option value="supply">物資情報 📦</option>
                        </select>
                    </div>
                    <div>
                        <label for="note-comment" class="block text-sm font-medium text-gray-700">コメント</label>
                        <input type="text" id="note-comment" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="例：この先の橋が通行止めです">
                    </div>
                    <div class="text-right pt-2">
                        <button id="submit-note-button" class="bg-blue-600 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-700">地図上で場所を指定</button>
                    </div>
                </div>
            `;
            showModal('共有情報を追加', content);
        }
        
        // --- Utility Functions ---
        function formatTextToHtml(text) {
            let html = text
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/### (.*$)/gm, '<h4>$1</h4>')
                .replace(/## (.*$)/gm, '<h3>$1</h3>')
                .replace(/# (.*$)/gm, '<h2>$1</h2>')
                .replace(/^\* (.*$)/gm, '<li>$1</li>');
            html = html.replace(/<li>/g, '<ul><li>').replace(/<\/li>/g, '</li></ul>');
            html = html.replace(/<\/ul>\s*<ul>/g, '');
            return html.replace(/\n/g, '<br>').replace(/<br><br>/g, '<br>');
        }
        function setApiButtonsState(inProgress) {
            isApiCallInProgress = inProgress;
            document.querySelectorAll('#toolbox button, .modal-container button').forEach(button => button.disabled = inProgress);
        }
        function getMagnitudeColor(mag) { if (mag >= 7) return '#b30000'; if (mag >= 6) return '#d73027'; if (mag >= 5) return '#fc8d59'; if (mag >= 4) return '#fee08b'; return '#91cf60'; }
        function getJmaShindoColor(shindo) { const map = { '7':'#580b27', '6強':'#b30000', '6弱':'#d73027', '5強':'#fc8d59', '5弱':'#fee08b', '4':'#ffffbf', '3':'#d9ef8b', '2':'#91cf60', '1':'#1a9850', '0':'#cccccc' }; return map[shindo] || '#cccccc'; }
        function convertMmiToRoman(mmi) { if (mmi == null || mmi < 1) return '情報なし'; const map = {1:'I', 2:'II', 3:'III', 4:'IV', 5:'V', 6:'VI', 7:'VII', 8:'VIII', 9:'IX'}; const roundedMmi = Math.round(mmi); if (roundedMmi >= 10) return 'X+'; return map[roundedMmi] || '情報なし'; }
        function convertMmiToJmaShindo(mmi) { if (mmi == null || mmi < 0) return '情報なし'; if (mmi < 0.5) return '0'; if (mmi < 1.5) return '1'; if (mmi < 2.5) return '2'; if (mmi < 3.5) return '3'; if (mmi < 4.5) return '4'; if (mmi < 5.0) return '5弱'; if (mmi < 5.5) return '5強'; if (mmi < 6.0) return '6弱'; if (mmi < 6.5) return '6強'; return '7'; }
        function convertScale(scale) { const scaleMap = { 10:'1', 20:'2', 30:'3', 40:'4', 45:'5弱', 50:'5強', 55:'6弱', 60:'6強', 70:'7' }; return scaleMap[scale] ?? '不明'; }
        function isDarkColor(hexcolor) { if (!hexcolor || !hexcolor.startsWith('#')) return false; const r = parseInt(hexcolor.substr(1, 2), 16), g = parseInt(hexcolor.substr(3, 2), 16), b = parseInt(hexcolor.substr(5, 2), 16); return ((r * 299) + (g * 587) + (b * 114)) / 1000 < 128; }
        function updateModeToggleButton() {
            const button = document.getElementById('mode-toggle-button');
            if (currentMode === 'japan') {
                button.title = '世界モードに切替';
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 008.716-6.747M12 21a9.004 9.004 0 01-8.716-6.747M12 21c2.485 0 4.5-4.03 4.5-9S14.485 3 12 3m0 18c-2.485 0-4.5-4.03-4.5-9S9.515 3 12 3m0 0a8.997 8.997 0 017.843 4.582M12 3a8.997 8.997 0 00-7.843 4.582m15.686 0A11.953 11.953 0 0112 10.5c-2.998 0-5.74-1.1-7.843-2.918m15.686 0A8.959 8.959 0 0121 12c0 .778-.099 1.533-.284 2.253m0 0A17.919 17.919 0 0112 16.5c-3.162 0-6.133-.815-8.716-2.247m0 0A9.015 9.015 0 013 12c0-1.605.42-3.113 1.157-4.418" /></svg>`;
            } else {
                button.title = '日本モードに切替';
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 6.75V15m6-6v8.25m.5-11.494l-2.024.953a.875.875 0 01-1.006 0l-2.83-1.331a.875.875 0 00-1.006 0l-2.909 1.365a.875.875 0 00-.527.824V18.25a.75.75 0 00.75.75h10.5a.75.75 0 00.75-.75V8.574a.875.875 0 00-.527-.824l-2.91-1.365a.875.875 0 00-1.005 0l-2.83 1.331a.875.875 0 01-1.006 0l-2.024-.953" /></svg>`;
            }
        }

        // --- Location Picker Logic ---
        function enterPinMode(targetInputId = 'location-input') {
            L.DomUtil.addClass(map.getContainer(), 'map-pin-mode');
            const instructionModal = showModal('場所を選択', '<p>地図上の目的の地点をクリックしてください。</p>');
            map.once('click', (e) => {
                onMapClick(e, targetInputId);
                instructionModal.querySelector('.modal-close').click();
            });
        }
        function enterPinDropMode() {
            L.DomUtil.addClass(map.getContainer(), 'map-pin-mode');
            map.once('click', (e) => {
                L.DomUtil.removeClass(map.getContainer(), 'map-pin-mode');
                handlePinDrop(e);
            });
        }
        async function updatePinAddress(marker, defaultText = "住所を検索中...") {
            const { lat, lng } = marker.getLatLng();
            userCoords = { lat, lng };
            marker.bindPopup(defaultText).openPopup();
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=ja`);
                if(!response.ok) throw new Error("Network response was not ok.");
                const data = await response.json();
                let displayAddress = '住所が見つかりませんでした';
                if (data && data.address) {
                    const address = data.address;
                    displayAddress = `${address.country || ''} ${address.state || ''} ${address.city || address.town || address.village || ''} ${address.road || ''} ${address.house_number || ''}`.trim();
                }
                userAddress = displayAddress;
                marker.getPopup().setContent(`<strong>指定した場所:</strong><br>${displayAddress}`);
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                userAddress = '住所の取得に失敗しました';
                marker.getPopup().setContent(userAddress);
            }
        }
        function handlePinDrop(e) {
            const { lat, lng } = e.latlng;
            if (locationMarker) { map.removeLayer(locationMarker); }
            const pinIcon = L.divIcon({className: 'text-4xl', html: '📍'});
            locationMarker = L.marker([lat, lng], {
                icon: pinIcon,
                draggable: true // Make the pin draggable
            }).addTo(map);
            
            locationMarker.on('dragend', function(event) {
                updatePinAddress(event.target);
            });
            updatePinAddress(locationMarker);
        }
        async function onMapClick(e, targetInputId = 'location-input') {
            const { lat, lng } = e.latlng;
            userCoords = { lat, lng };
            L.DomUtil.removeClass(map.getContainer(), 'map-pin-mode');
            const locationInput = document.getElementById(targetInputId);
            if (!locationInput) return;
            locationInput.value = '座標から住所を検索中...';
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&accept-language=ja`);
                if(!response.ok) throw new Error("Network response was not ok.");
                const data = await response.json();
                if (data && data.address) {
                    const address = data.address;
                    const displayAddress = `${address.country || ''} ${address.state || ''} ${address.city || address.town || address.village || ''}`.trim();
                    userAddress = displayAddress;
                    locationInput.value = displayAddress || '住所が見つかりません';
                } else {
                    userAddress = '住所が見つかりませんでした';
                    locationInput.value = userAddress;
                }
            } catch (error) {
                console.error("Reverse geocoding failed:", error);
                userAddress = '住所の取得に失敗しました';
                locationInput.value = userAddress;
            }
        }
        function getCurrentLocation(targetInputId = 'location-input') {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => onMapClick({ latlng: { lat: position.coords.latitude, lng: position.coords.longitude } }, targetInputId),
                    (error) => showModal('GPSエラー', `<p>GPS情報の取得に失敗しました: ${error.message}</p>`)
                );
            } else {
                showModal('GPSエラー', '<p>お使いのブラウザはGPS機能に対応していません。</p>');
            }
        }
        
        // --- Drone Animation Logic ---
        function initializeDroneMap(mapInstance, start, end, durationMinutes, missionLog) {
            // Clear previous drone elements
            droneLayer.clearLayers();
            droneMarkers = [];
            if (droneAnimationId) cancelAnimationFrame(droneAnimationId);

            const startCoords = L.latLng(start[0], start[1]);
            const endCoords = L.latLng(end[0], end[1]);

            const destinationIcon = L.divIcon({className: 'text-4xl', html: '🏠'});
            const droneBaseIcon = L.divIcon({className: 'text-4xl', html: '📡'});
            const droneIcon = L.divIcon({className: 'text-4xl drone-icon', html: '🚁'});

            const destMarker = L.marker(endCoords, {icon: destinationIcon}).addTo(droneLayer).bindTooltip("目的地");
            const baseMarker = L.marker(startCoords, {icon: droneBaseIcon}).addTo(droneLayer).bindTooltip("ドローン基地");
            
            const route = L.polyline([startCoords, endCoords], {color: 'blue', dashArray: '5, 10'}).addTo(droneLayer);
            const movingDrone = L.marker(startCoords, {icon: droneIcon}).addTo(droneLayer);

            droneMarkers.push(destMarker, baseMarker, route, movingDrone); // Keep track for clearing

            mapInstance.fitBounds(L.featureGroup([destMarker, baseMarker]).getBounds().pad(0.2)); // Fit bounds to start and end points

            // Show drone dashboard
            droneDashboard.classList.remove('hidden');
            // Clear mission log
            const missionLogEl = document.getElementById('mission-log');
            if (missionLogEl) missionLogEl.innerHTML = '';

            // Reset drone state for new animation
            currentDroneState = {
                speed: 0,
                altitude: 0,
                battery: 100,
                windSpeed: 0,
                obstacleDetected: false,
                targetSpeed: 50, // km/h
                targetAltitude: 100, // meters
                targetWindSpeed: 5 // m/s
            };

            animateDrone(movingDrone, route, durationMinutes * 60 * 1000, missionLog);
        }

        // New function to display static drone path
        function displayStaticDronePath(start, end) {
            droneLayer.clearLayers(); // Clear any existing drone elements

            const startCoords = L.latLng(start[0], start[1]);
            const endCoords = L.latLng(end[0], end[1]);

            const destinationIcon = L.divIcon({className: 'text-4xl', html: '🏠'});
            const droneBaseIcon = L.divIcon({className: 'text-4xl', html: '📡'});

            L.marker(endCoords, {icon: destinationIcon}).addTo(droneLayer).bindTooltip("目的地");
            L.marker(startCoords, {icon: droneBaseIcon}).addTo(droneLayer).bindTooltip("ドローン基地");
            
            L.polyline([startCoords, endCoords], {color: 'blue', dashArray: '5, 10'}).addTo(droneLayer);

            map.fitBounds(L.featureGroup([L.marker(startCoords), L.marker(endCoords)]).getBounds().pad(0.2)); // Fit bounds
        }
        
        function animateDrone(marker, route, duration, missionLog) {
            if (droneAnimationId) cancelAnimationFrame(droneAnimationId);
            let start = null;
            const latlngs = route.getLatLngs();
            const missionLogEl = document.getElementById('mission-log');
            const speedEl = document.getElementById('drone-speed');
            const altitudeEl = document.getElementById('drone-altitude');
            const batteryEl = document.getElementById('drone-battery');
            const windSpeedEl = document.getElementById('drone-wind-speed');
            const obstacleDetectionEl = document.getElementById('drone-obstacle-detection');
            const etaEl = document.getElementById('drone-eta');

            let currentLogIndex = 0;
            let lastUpdateTimestamp = 0;
            const updateInterval = 500; // Update every 500ms for smoother values

            function animationStep(timestamp) {
                if (!start) start = timestamp;
                const progress = timestamp - start;
                const ratio = Math.min(progress / duration, 1);

                // Update mission log
                if (missionLogEl && (currentLogIndex < missionLog.length) && (missionLog[currentLogIndex].time * 60 * 1000) <= progress) {
                    const logEntry = document.createElement('p');
                    logEntry.textContent = `[${new Date(Date.now() + progress).toLocaleTimeString()}] ${missionLog[currentLogIndex].event}`;
                    missionLogEl.appendChild(logEntry);
                    missionLogEl.scrollTop = missionLogEl.scrollHeight;
                    currentLogIndex++;
                }

                // Update real-time info more realistically
                if (timestamp - lastUpdateTimestamp > updateInterval) {
                    // Speed: gradually approach target, with small fluctuations
                    const speedChange = (currentDroneState.targetSpeed - currentDroneState.speed) * 0.1 + (Math.random() - 0.5) * 1; // +/- 0.5 km/h
                    currentDroneState.speed = Math.max(0, Math.min(currentDroneState.targetSpeed * 1.1, currentDroneState.speed + speedChange));
                    if(speedEl) speedEl.textContent = `${currentDroneState.speed.toFixed(1)}`;

                    // Altitude: gradually approach target, with small fluctuations
                    const altitudeChange = (currentDroneState.targetAltitude - currentDroneState.altitude) * 0.1 + (Math.random() - 0.5) * 0.5; // +/- 0.25 m
                    currentDroneState.altitude = Math.max(0, Math.min(currentDroneState.targetAltitude * 1.1, currentDroneState.altitude + altitudeChange));
                    if(altitudeEl) altitudeEl.textContent = `${currentDroneState.altitude.toFixed(1)}`;

                    // Battery: mostly linear, with minor random drain
                    currentDroneState.battery = Math.max(0, currentDroneState.battery - (0.01 + Math.random() * 0.02)); // Drain 0.01-0.03% per update
                    if(batteryEl) batteryEl.textContent = `${currentDroneState.battery.toFixed(1)}`;

                    // Wind Speed: gradual random fluctuations
                    const windChange = (Math.random() - 0.5) * 0.2; // +/- 0.1 m/s
                    currentDroneState.windSpeed = Math.max(0, Math.min(currentDroneState.targetWindSpeed * 1.2, currentDroneState.windSpeed + windChange));
                    if(windSpeedEl) windSpeedEl.textContent = `${currentDroneState.windSpeed.toFixed(1)}`;

                    // Obstacle Detection: low probability, but can "stick" for a bit
                    if (Math.random() < 0.005) { // 0.5% chance per update
                        currentDroneState.obstacleDetected = true;
                        if(obstacleDetectionEl) obstacleDetectionEl.textContent = '検知！';
                    } else if (currentDroneState.obstacleDetected && Math.random() < 0.1) { // 10% chance to clear if detected
                        currentDroneState.obstacleDetected = false;
                        if(obstacleDetectionEl) obstacleDetectionEl.textContent = 'なし';
                    } else if (!currentDroneState.obstacleDetected) {
                        if(obstacleDetectionEl) obstacleDetectionEl.textContent = 'なし';
                    }

                    lastUpdateTimestamp = timestamp;
                }

                const remainingMinutes = (duration - progress) / 1000 / 60;
                if(etaEl) etaEl.textContent = `${Math.max(0, remainingMinutes).toFixed(1)} 分`;

                if (ratio < 1) {
                    const newLatLng = L.latLng(
                        latlngs[0].lat + ratio * (latlngs[1].lat - latlngs[0].lat),
                        latlngs[0].lng + ratio * (latlngs[1].lng - latlngs[0].lng)
                    );
                    marker.setLatLng(newLatLng);
                    droneAnimationId = requestAnimationFrame(animationStep);
                } else {
                    marker.setLatLng(latlngs[1]);
                    marker.setIcon(L.divIcon({className: 'text-4xl', html: '✅'}));
                    if(etaEl) etaEl.textContent = '到着済み';
                    // Hide dashboard and clear drone elements after completion
                    setTimeout(() => {
                        droneDashboard.classList.add('hidden');
                        // Only clear droneLayer if no narrative modal is open and showing static path
                        // Or, more simply, just clear it after animation completes.
                        // The static path logic in showDroneNarrativeModal will redraw it if needed.
                        droneLayer.clearLayers();
                        droneMarkers = [];
                    }, 3000); // Hide after 3 seconds
                }
            }
            droneAnimationId = requestAnimationFrame(animationStep);
        }

        function cancelDroneMission() {
            if (droneAnimationId) {
                cancelAnimationFrame(droneAnimationId);
                droneAnimationId = null;
            }
            droneLayer.clearLayers();
            droneMarkers = [];
            droneDashboard.classList.add('hidden');
            showModal('ミッションキャンセル', '<p>ドローンミッションがキャンセルされました。</p>');
        }

        // --- Event Listeners ---
        document.getElementById('mode-toggle-button').addEventListener('click', () => {
            switchMode(currentMode === 'japan' ? 'world' : 'japan');
        });
        document.getElementById('filter-button').addEventListener('click', showFilterModal);
        document.getElementById('ai-tools-button').addEventListener('click', showAiToolsModal);
        document.getElementById('info-share-button').addEventListener('click', showInfoShareModal);
        document.getElementById('drone-request-button').addEventListener('click', handleDroneRequest);
        document.getElementById('cancel-drone-mission').addEventListener('click', cancelDroneMission);
        
        // Event listener for showing drone narrative
        showDroneNarrativeButton.addEventListener('click', showDroneNarrativeModal);


        // Delegated event listener for buttons inside modals
        document.body.addEventListener('click', (e) => {
            const target = e.target.closest('button');
            if(!target || !target.id) return;
            
            switch(target.id) {
                case 'analysis-button': generateAnalysis(); break;
                case 'prepare-button': generatePreparednessTips(); break;
                case 'safety-report-button': {
                    const locationInput = document.getElementById('location-input');
                    const householdType = document.getElementById('household-type');
                    generateSafetyReport(locationInput?.value, householdType?.value); 
                    break;
                }
                case 'map-select-button': enterPinMode('location-input'); break;
                case 'gps-button': getCurrentLocation('location-input'); break;
                case 'power-outage-button': generatePowerOutageReport(); break;
                case 'drone-future-button': generateDroneFutureReport(); break;
                case 'transit-advice-button': generateTransitAdvice(); break;
                case 'apply-filter-button': {
                    applyFilters();
                    target.closest('.modal-overlay')?.querySelector('.modal-close').click();
                    break;
                }
                case 'submit-note-button': {
                    const formModal = target.closest('.modal-overlay');
                    const type = formModal.querySelector('#note-type').value;
                    const commentInput = formModal.querySelector('#note-comment');
                    const comment = commentInput.value;
                    if (!comment) {
                        commentInput.placeholder = "コメントを入力してください";
                        commentInput.classList.add('border-red-500');
                        return;
                    }
                    const icons = { danger: '⚠️', support: '🤝', supply: '📦' };

                    formModal.querySelector('.modal-close').click();
                    const instructionModal = showModal('情報追加', '<p>地図上の情報を追加したい地点をクリックしてください。</p>');
                    
                    map.once('click', (mapClickEvent) => {
                        L.marker(mapClickEvent.latlng, { icon: L.divIcon({className: 'text-2xl', html: icons[type]}) })
                            .addTo(notesLayer)
                            .bindPopup(`<strong>${type}</strong><br>${comment}`);
                        instructionModal.querySelector('.modal-close').click();
                    });
                    break;
                }
            }
        });

        // --- Initial Load ---
        switchMode('japan');
        fetchTectonicPlates();
    });
    </script>
</body>
</html>

